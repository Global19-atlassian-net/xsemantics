package it.xsemantics.dsl.tests.generator

import it.xsemantics.dsl.XsemanticsInjectorProvider
import org.eclipse.xtext.junit4.InjectWith
import org.eclipse.xtext.junit4.XtextRunner
import org.eclipse.xtext.xbase.compiler.IAppendable
import org.junit.Test
import org.junit.runner.RunWith

@InjectWith(typeof(XsemanticsInjectorProvider))
@RunWith(typeof(XtextRunner))
class XsemanticsRuleGeneratorTest extends XsemanticsGeneratorBaseTest {

	@Test
	def void testAppendableForXbaseGeneratedVariables() {
		// we simulate the declaration of a variable representing
		// the parameter of the rule (which would end up clashing with
		// a local variable generated by the Xbase compiler)
		checkDeclaredVariable(
			"_createEObject",
			"_createEObject_1",
			testFiles.
			testRuleWithExpressionInConclusionWithInputParamNameAsXbaseGeneratedVariable
		)
	}
	
	@Test
	def void testOutputParamFromInputParam() {
		checkCompileApplyMethod(testFiles.testOutputParamFromInputParam(),
'''

protected Result<EClass> applyRuleEObjectEClass(final RuleEnvironment G, final RuleApplicationTrace _trace_,
		final EClass eClass) 
		throws RuleFailedException {
	return new Result<EClass>(eClass);
}
'''
		)
	}
	
	@Test
	def void testRuleWithErrorSpecifications() {
		checkCompileDispatcherImplMethod(testFiles.testRuleWithErrorSpecifications(),
'''
protected Result<Boolean> typeImpl(final RuleEnvironment G, final RuleApplicationTrace _trace_,
		final EClass eClass, final EObject object) 
		throws RuleFailedException {
	try {
		RuleApplicationTrace _subtrace_ = newTrace(_trace_);
		Result<Boolean> _result_ = applyRuleEClassEObject(G, _subtrace_, eClass, object);
		addToTrace(_trace_, ruleName("EClassEObject") + stringRepForEnv(G) + " |- " + stringRep(eClass) + " : " + stringRep(object));
		addAsSubtrace(_trace_, _subtrace_);
		return _result_;
	} catch (Exception e_applyRuleEClassEObject) {
		
		String _stringRep = this.stringRep(object);
		String _operator_plus = StringExtensions.operator_plus("this ", _stringRep);
		String _operator_plus_1 = StringExtensions.operator_plus(_operator_plus, " made an error!");
		String error = _operator_plus_1;
		EClass _eClass = object.eClass();
		EObject source = _eClass;
		EClass _eClass_1 = object.eClass();
		EStructuralFeature _eContainingFeature = _eClass_1.eContainingFeature();
		EStructuralFeature feature = _eContainingFeature;
		throwRuleFailedException(error,
			ECLASSEOBJECT, e_applyRuleEClassEObject,
			new ErrorInformation(source, feature));
		return null;
	}
}
'''
		)
	}
	
	def void checkDeclaredVariable(String newVarName, String expected, CharSequence inputProgram) {
		checkDeclaredVariable(newVarName, expected,
			inputProgram.firstRule.createAppendable
		)
	}
	
	def void checkDeclaredVariable(String newVarName, String expected, IAppendable appendable) {
		assertEqualsStrings(expected, 
			appendable.declareVariable(new String(), newVarName)
		)
	}
	
	def void checkCompileApplyMethod(CharSequence program, CharSequence expected) {
		val rule = program.firstRule
		assertEqualsStrings(expected,
			ruleGenerator.compileApplyMethod(rule, createImportManager)
		)
	}
	
	def void checkCompileDispatcherImplMethod(CharSequence program, CharSequence expected) {
		val rule = program.firstRule
		assertEqualsStrings(expected,
			ruleGenerator.compileDispatcherImplMethod(rule, createImportManager)
		)
	}

}