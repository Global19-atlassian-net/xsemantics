// alternative type system for FJ using external auxiliary functions

system it.xsemantics.test.fj.alt.FjAltTypeSystem extends it.xsemantics.test.fj.first.FjFirstTypeSystem

import it.xsemantics.example.fj.fj.*
import it.xsemantics.example.fj.util.*
import it.xsemantics.example.fj.lookup.*

import org.eclipse.emf.ecore.EObject

import org.eclipse.xtext.EcoreUtil2

import org.eclipse.xtext.xbase.lib.CollectionLiterals

import com.google.common.collect.Lists

import java.util.*

inject FjAuxiliaryFunctions fjAux

judgments {
	override classtype ||~ Expression expression : output ClassType
		error stringRep(expression) + " has not a class type"
		source expression
	override subtype |- Type left <: Type right
		error stringRep(left) + " is not a subtype of " + stringRep(right)
		source left
	override subclass |- Class candidate <| Class superclass
		error candidate.name + " is not a subclass of " + superclass.name
		source candidate
		feature FjPackage::eINSTANCE.class_Name
}

rule TypeEquals
	G |- Type left ~~ Type right
		error stringRep(left) + " and " + stringRep(right) +
			" are not comparable"
from {
	// this is the most general case
	// which always fails
	fail
}

override rule CheckNew derives
	G |- New newExp
from {
	var fields = fjAux.getFields(newExp.type.classref)
	G |- newExp : newExp.args << fields
	// check all subexpressions (arguments)
	newExp.args.forEach [ G |- it ]
}

override rule CheckClass
	G |- Class cl
from {
	if (cl.superclass != null) {
		var List<Class> superClasses = fjAux.getSuperclasses(cl)
		!superClasses.contains(cl)
		
		var inheritedFields = fjAux.getFields(cl.superclass)
		inheritedFields.forEach [
			inheritedField |
			for (field : fjAux.selectFields(cl)) {
				field.name != inheritedField.name
				or
				fail
					error "field already defined in superclass " +
						stringRep(inheritedField.eContainer)
			}
		]
		
		var inheritedMethods = fjAux.getMethods(cl.superclass)
		// check override predicate
		inheritedMethods.forEach [
			inheritedMethod |
			fjAux.selectMethods(cl).forEach [
				it.name != inheritedMethod.name
				or
				{
					G |- it.type ~~ inheritedMethod.type
					
					it.params.size == inheritedMethod.params.size
					val inheritedMethodParamsIt = inheritedMethod.params.iterator
					for (param : it.params) {
						G |- param.type ~~ inheritedMethodParamsIt.next.type
					}
				}
			]
		]
	}
}

checkrule CheckMain for
	Program program
from {
	program.main == null // nothing to check
	or
	empty |- program.main
}

checkrule CheckClassOk for
	Class clazz
from {
	empty |- clazz
}

checkrule CheckMethodBody for
	Method method
from {
}

checkrule CheckField for
	Field field
from {
}

checkrule CheckMethodOverride for
	Method method
from {

}

checkrule CheckClassHierachyNotCyclic for
	Class cl
from {

}

