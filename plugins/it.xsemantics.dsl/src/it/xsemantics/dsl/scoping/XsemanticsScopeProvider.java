/*
 * generated by Xtext
 */
package it.xsemantics.dsl.scoping;

import static com.google.common.collect.Lists.newArrayList;
import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;
import static org.eclipse.xtext.xbase.lib.IterableExtensions.head;
import it.xsemantics.dsl.util.XsemanticsUtils;
import it.xsemantics.dsl.xsemantics.Rule;
import it.xsemantics.dsl.xsemantics.RuleInvocation;
import it.xsemantics.dsl.xsemantics.RuleParameter;

import java.util.List;
import java.util.Set;

import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.common.types.JvmDeclaredType;
import org.eclipse.xtext.common.types.JvmOperation;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.xbase.XBlockExpression;
import org.eclipse.xtext.xbase.XExpression;
import org.eclipse.xtext.xbase.XVariableDeclaration;
import org.eclipse.xtext.xbase.jvmmodel.IJvmModelAssociations;
import org.eclipse.xtext.xbase.scoping.LocalVariableScopeContext;
import org.eclipse.xtext.xbase.scoping.XbaseScopeProvider;
import org.eclipse.xtext.xbase.scoping.featurecalls.IValidatedEObjectDescription;
import org.eclipse.xtext.xbase.scoping.featurecalls.JvmFeatureScope;
import org.eclipse.xtext.xbase.validation.IssueCodes;

import com.google.common.collect.Lists;
import com.google.inject.Inject;

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping on
 * how and when to use it
 * 
 */
@SuppressWarnings("restriction")
public class XsemanticsScopeProvider extends XbaseScopeProvider {
	@Inject
	protected XsemanticsUtils utils;

	@Inject
	protected IJvmModelAssociations associations;

	@Override
	protected IScope createLocalVarScopeForJvmOperation(JvmOperation context,
			IScope parentScope) {
		parentScope = super.createLocalVarScopeForJvmOperation(context,
				parentScope);

		// we need the original source Rule (associated to the method
		// created by our model inferrer), in order to add to the scope
		// the output parameters of the Rule (which will correspond to
		// local variables in the generated code).
		EObject sourceElement = associations.getPrimarySourceElement(context);
		if (sourceElement instanceof Rule) {
			Rule rule = (Rule) sourceElement;
			List<IValidatedEObjectDescription> descriptions = newArrayList();
			addRuleParamsInDescriptions(utils.outputParams(rule), descriptions);
			return new JvmFeatureScope(parentScope, "operation "
					+ context.getSimpleName(), descriptions);
		}

		return parentScope;
	}

	private void addRuleParamsInDescriptions(List<RuleParameter> params,
			List<IValidatedEObjectDescription> descriptions) {
		for (RuleParameter p : params) {
			if (p.getParameter() != null && p.getParameter().getName() != null)
				descriptions.add(createLocalVarDescription(p.getParameter()));
		}
	}

	@Override
	protected IScope createLocalVarScope(IScope parentScope,
			LocalVariableScopeContext scopeContext) {
		if (scopeContext == null || scopeContext.getContext() == null)
			return parentScope;
		EObject context = scopeContext.getContext();

		// to a Rule the inferrer associates both field(s) and methods
		// and we need the method (i.e., the JvmOperation) to actually
		// build a correct scope
		JvmOperation jvmOperation = getJvmOperationAssociatedToSourceElement(context);

		if (jvmOperation == null)
			return super.createLocalVarScope(parentScope, scopeContext);
		else {
			if (jvmOperation.getDeclaringType() != null) {
				JvmDeclaredType declaredType = jvmOperation.getDeclaringType();
				if (!jvmOperation.isStatic()) {
					parentScope = createLocalVarScopeForJvmDeclaredType(
							declaredType, parentScope);
				}
			}
			return createLocalVarScopeForJvmOperation(jvmOperation, parentScope);
		}

	}

	private JvmOperation getJvmOperationAssociatedToSourceElement(
			EObject context) {
		EObject sourceElement = associations.getPrimarySourceElement(context);

		if (sourceElement == null)
			return null;

		Set<EObject> jvmElements = associations.getJvmElements(sourceElement);
		JvmOperation jvmOperation = head(filter(jvmElements, JvmOperation.class));
		return jvmOperation;
	}

	@Override
	protected IScope createLocalVarScopeForBlock(XBlockExpression block,
			int indexOfContextExpressionInBlock, boolean referredFromClosure,
			IScope parentScope) {
		// copied from XbaseScopeProvider with the case for RuleInvocation's
		// variable declarations
		List<IValidatedEObjectDescription> descriptions = Lists.newArrayList();
		for (int i = 0; i < indexOfContextExpressionInBlock; i++) {
			XExpression expression = block.getExpressions().get(i);
			if (expression instanceof XVariableDeclaration) {
				XVariableDeclaration varDecl = (XVariableDeclaration) expression;
				addVariableDeclaration(descriptions, varDecl,
						referredFromClosure);
			} else if (expression instanceof RuleInvocation) {
				RuleInvocation ruleInvocation = (RuleInvocation) expression;
				List<XVariableDeclaration> variableDeclarations = utils
						.getVariableDeclarations(ruleInvocation);
				for (XVariableDeclaration varDecl : variableDeclarations) {
					addVariableDeclaration(descriptions, varDecl,
							referredFromClosure);
				}
			}
		}
		if (descriptions.isEmpty())
			return parentScope;
		return new JvmFeatureScope(parentScope, "XBlockExpression",
				descriptions);
	}

	protected void addVariableDeclaration(
			List<IValidatedEObjectDescription> descriptions,
			XVariableDeclaration varDecl, boolean referredFromClosure) {
		if (varDecl.getName() != null) {
			IValidatedEObjectDescription desc = createLocalVarDescription(varDecl);
			if (referredFromClosure && varDecl.isWriteable())
				desc.setIssueCode(IssueCodes.INVALID_MUTABLE_VARIABLE_ACCESS);
			descriptions.add(desc);
		}
	}
}
