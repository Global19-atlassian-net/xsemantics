/*
 * A version of the FJ system where type computation involves also
 * type checking.
 */
system it.xsemantics.example.fj.typing.FjTypeSystem

import it.xsemantics.example.fj.fj.*
import it.xsemantics.example.fj.util.*
import it.xsemantics.example.fj.lookup.*

import org.eclipse.emf.ecore.EObject

import org.eclipse.xtext.EcoreUtil2

import org.eclipse.xtext.xbase.lib.CollectionLiterals

import com.google.common.collect.*

import java.util.*

inject FjAuxiliaryFunctions fjAux
inject FjSemanticsUtils semanticsUtils

auxiliary {
	superclasses(Class cl) : List<Class>
}

judgments {
	type |- Expression expression : output Type
		error "cannot type " + stringRep(expression)
		source expression
	classtype |~ Expression expression : output ClassType
		error stringRep(expression) + " has not a class type"
		source expression
	subtype |- Type left <: Type right
		error stringRep(left) + " is not a subtype of " + stringRep(right)
	assignable |- Expression expression <| Type right
		error stringRep(expression) + " is not assignable for " + stringRep(right)
		source expression
	equalstype |- Type left ~~ Type right
		error stringRep(left) + " is not the same type as " + stringRep(right)
	overrides ||- Method current ~~ Method previous
		error current.name + " does not override the superclass method"
		source current
	subtypesequence |- Expression owner ~> List<Expression> expressions << List<? extends TypedElement> elements
		error "invalid arguments for expected parameters"
		source owner
	reduce |- Expression exp ~> output Expression
	subjred |= Expression exp ~> output Expression : output Type <: output Type
}

auxiliary superclasses(Class cl) {
	getAll(cl,
		FjPackage::eINSTANCE.class_Superclass,
		FjPackage::eINSTANCE.class_Superclass,
		typeof(Class)
	)
}

axiom TThis
	G |- This _this : env(G, 'this', ClassType)

rule TNew
	G |- New newExp : newExp.type
from {
	var fields = fjAux.getFields(newExp.type.classref)
	// we want the superclasses' fields first
	G |- newExp ~> newExp.args << fields
}

axiom TParamRef 
	G |- ParamRef paramref : paramref.parameter.type

// you can manually create the BasicType with EMF FjFactory...
axiom TStringConstant
	G |- StringConstant s : { 
			val result = FjFactory::eINSTANCE.createBasicType();
			result.basic = 'String'
			result
		}

// ...or use static utility methods...
axiom TIntConstant
	G |- IntConstant i : FjTypeUtils::createIntType

// ...or closures
axiom TBoolConstant
	G |- BoolConstant b : 
	[ 
		it.basic='boolean'
		it
	].apply(FjFactory::eINSTANCE.createBasicType())

rule TSelection
	G |- Selection selection : selection.message.type
from {
	G |- selection.receiver : var ClassType receiverType
	// check message if it's a method call
	val message = selection.message
	switch (message) {
		Method: { 
			G |- selection ~> selection.args << message.params
		}
	}
}

rule TCast
	G |- Cast cast : cast.type
from {
	G |- cast.expression : var Type expType
	
	G |- cast.type <: expType
	or
	G |- expType <: cast.type
}

rule TExpressionClassType
	G |~ Expression expression : ClassType classType
from {
	G |- expression : classType
}

rule GeneralSubtyping
	G |- Type left <: Type right
		error "types " + stringRep(left) + " and " + stringRep(right) +
			" are not comparable"
from {
	// if we get here we're trying to mix
	// a BasicType with a ClassType, thus, we fail
	fail
}

rule BasicSubtyping
	derives G |- BasicType left <: BasicType right
from {
	left.basic.equals(right.basic)
}

rule ClassSubtyping
	derives G |- ClassType left <: ClassType right
from {
	left.classref == right.classref
	or
	right.classref.name == "Object"
	or {
		getAll(left.classref, 
			FjPackage::eINSTANCE.class_Superclass,
			FjPackage::eINSTANCE.class_Superclass,
			typeof(Class))
		.contains(right.classref)
	}
}

rule ExpressionAssignableToType
	G |- Expression expression <| Type right
from {
	var Type expressionType
	G |- expression : expressionType
	G |- expressionType <: right
}

rule GeneralEquals
	G |- Type left ~~ Type right
		error "types " + stringRep(left) + " and " + stringRep(right) +
			" are not comparable"
from {
	// if we get here we're trying to mix
	// a BasicType with a ClassType, thus, we fail
	fail
}

rule BasicEquals
	derives G |- BasicType left ~~ BasicType right
from {
	left.basic.equals(right.basic)
}

rule ClassEquals
	derives G |- ClassType left ~~ ClassType right
from {
	left.classref == right.classref
}

rule SubtypeSequence derives
	G |- Expression owner ~> 
		List<Expression> expressions << List<TypedElement> typedElements
from {
	expressions.size == typedElements.size
	or
	fail
		error "expected " + typedElements.size + " arguments, but got " +
			expressions.size
		source owner 
	
	val typedElementsIterator = typedElements.iterator
	for (exp : expressions) {
		G |- exp <| typedElementsIterator.next.type
	}
}

rule MethodOverride
	G ||- Method current ~~ Method previous
from {
	current.name != previous.name
	or
	{
		G |- current.type ~~ previous.type
		or
		fail error 
		"cannot change return type of inherited method: " +
			stringRep(previous.type)
		source current
		feature FjPackage::eINSTANCE.typedElement_Type
		
		current.params.size == previous.params.size
		val previousParamsIt = previous.params.iterator
		for (param : current.params) {
			G |- param.type ~~ previousParamsIt.next.type
		}
	}
}

rule RNew
	G |- New exp ~> New exp1
from {
	exp1 = clone(exp)
	val indexOfNextToReduce = Iterables::indexOf(exp1.args) [
		!semanticsUtils.isValue(it)
	]
	{
		// all constructor's arguments are values
		indexOfNextToReduce < 0
	}
	or
	{
		// we need to evaluate an argument
		val nextToReduce = exp1.args.get(indexOfNextToReduce)
		G |- nextToReduce ~> var Expression expi
		exp1.args.set(indexOfNextToReduce, expi)
	}
}

rule RSelection
	G |- Selection exp ~> Expression exp1
from {
	{
		// the receiver is not a value yet
		val sel = clone(exp)
		!semanticsUtils.isValue(exp.receiver)
		G |- exp.receiver ~> var Expression expi
		sel.receiver = expi
		exp1 = sel
	}
	or
	{
		val receiver = exp.receiver as New
		val message = exp.message
		switch (message) {
			Field: {
				// find the value's field corresponding
				// to the requested field
				val fieldIndex = Iterables::indexOf(
					fjAux.getFields(receiver.type.classref))
				[
					name == message.name
				]
				exp1 = receiver.args.get(fieldIndex)
			}
			Method: {
				val indexOfNextToReduce = Iterables::indexOf(exp.args) [
					!semanticsUtils.isValue(it)
				]
				{
					// all invocation's arguments are values
					indexOfNextToReduce < 0
					val method = clone(exp.message) as Method
					semanticsUtils.replaceThisAndParams(
						method.body.expression, receiver,
						method.params, exp.args)
					exp1 = method.body.expression
				}
				or
				{
					// we need to evaluate an argument
					val sel = clone(exp)
					val nextToReduce = sel.args.get(indexOfNextToReduce)
					G |- nextToReduce ~> var Expression argi
					sel.args.set(indexOfNextToReduce, argi)
					exp1 = sel
				}
			}
		}
	}
}

rule RCast
	G |- Cast exp ~> Expression exp1
from {
	val cast = clone(exp)
	if (semanticsUtils.isValue(cast.expression)) {
		G |- cast.expression <| cast.type
		exp1 = cast.expression
	} else {
		G |- cast.expression ~> var Expression expi
		cast.expression = expi
		exp1 = cast
	}
}

rule SubjRed
	G |= Expression e ~> Expression e1 : Type T1 <: Type T
from {
	G |- e : T
	G |- e ~> e1
	G |- e1 : T1
	G |- T1 <: T
}

// checkrules (for the generated validator)

checkrule CheckMethodBody for
	Method method
from {
	val typeForThis = FjTypeUtils::createClassType(
		EcoreUtil2::getContainerOfType(method, typeof(Class))
	)
	'this' <- typeForThis |- method.body.expression <| method.type
}

checkrule CheckField for
	Field field
from {
	val clazz = field.eContainer as Class
	
	if (clazz.superclass != null) {
		var inheritedFields = getAll(
			clazz.superclass,
			FjPackage::eINSTANCE.class_Members,
			FjPackage::eINSTANCE.class_Superclass,
			typeof(Field)
		)
		// make sure no duplicate fields in the hierarchy
		inheritedFields.forEach [
			inheritedField |
			if (field.name == inheritedField.name) {
				fail
					error "field already defined in superclass " +
						stringRep(inheritedField.eContainer)
			}
		]
	}
}

checkrule CheckMethodOverride for
	Method method
from {
	val clazz = method.eContainer as Class
	
	if (clazz.superclass != null) {
		var inheritedMethods = getAll(
			clazz.superclass,
			FjPackage::eINSTANCE.class_Members,
			FjPackage::eINSTANCE.class_Superclass,
			typeof(Method)
		)
		// check override predicate
		inheritedMethods.forEach [
			inheritedMethod |
			fjAux.selectMethods(clazz).forEach [
				empty ||- it ~~ inheritedMethod
			]
		]
	}
}

checkrule CheckClassHierachyNotCyclic for
	Class cl
from {
	if (cl.superclass != null) {
		!getAll(
			cl,
			FjPackage::eINSTANCE.class_Superclass,
			FjPackage::eINSTANCE.class_Superclass,
			typeof(Class)
		).contains(cl)
		or
		fail
			error "Cyclic hierarchy for " + cl.name
			source cl
	}
}

checkrule CheckMain for
	Program program
from {
	program.main == null // nothing to check
	or
	empty |- program.main : var Type mainType
}
