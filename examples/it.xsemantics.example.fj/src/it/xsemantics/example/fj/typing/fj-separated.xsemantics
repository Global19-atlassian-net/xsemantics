/*
 * A version of the FJ system where type computation and
 * checking are separated.
 */
system it.xsemantics.example.fj.typing.FjSepTypeSystem extends it.xsemantics.example.fj.typing.FjTypeSystem

import it.xsemantics.example.fj.fj.*
import it.xsemantics.example.fj.util.*
import it.xsemantics.example.fj.lookup.*

import org.eclipse.emf.ecore.EObject

import org.eclipse.xtext.EcoreUtil2

import org.eclipse.xtext.xbase.lib.CollectionLiterals

import com.google.common.collect.Lists

import java.util.*

inject FjAuxiliaryFunctions fjAux

judgments {
	check |- EObject obj
}

override axiom TNew
	G |- New newExp : newExp.type

override axiom TSelection
	G |- Selection selection : selection.message.type

override axiom TCast
	G |- Cast cast : cast.type

// a Constant is always OK
axiom CheckConstant
	G |- Constant _const

// a TypedElement is always OK
axiom CheckTypedElement
	G |- TypedElement typedElement

// a ParamRef is always OK
axiom CheckParamRef
	G |- ParamRef paramref

rule CheckThis
	G |- This _this
from {
	env(G, 'this', ClassType) != null
}

rule CheckMethod derives
	G |- Method method
from {
	val typeForThis = FjTypeUtils::createClassType(
		EcoreUtil2::getContainerOfType(method, typeof(Class))
	)
	var Type bodyType
	G, 'this' <- typeForThis |- method.body.expression : bodyType
	G |- bodyType <: method.type
	G, 'this' <- typeForThis |- method.body.expression
}

rule CheckNew derives
	G |- New newExp
from {
	var fields = getAll(
		newExp.type.classref,
		FjPackage::eINSTANCE.class_Members,
		FjPackage::eINSTANCE.class_Superclass,
		typeof(Field)
	)
	// we want the superclasses' fields first
	Collections::reverse(fields)
	G |- newExp ~> newExp.args << fields
	// check all subexpressions (arguments)
	newExp.args.forEach [ G |- it ]
}

rule CheckSelection derives
	G |- Selection selection
from {
	// check receiver
	G |- selection.receiver
	// check message if it's a method call
	val message = selection.message
	switch (message) {
		Method: { 
			G |- selection ~> selection.args << message.params
			// check all subexpressions (arguments)
			for (arg : selection.args) {
				G |- arg
			}
		}
	}
}

rule CheckCast
	G |- Cast cast
from {
	var Type expType
	G |- cast.expression : expType
	
	G |- cast.type <: expType
	or
	G |- expType <: cast.type
}

rule CheckClass
	G |- Class cl
from {
	cl.members.forEach [ G |- it ]
	
	if (cl.superclass != null) {
		var inheritedFields = getAll(
			cl.superclass,
			FjPackage::eINSTANCE.class_Members,
			FjPackage::eINSTANCE.class_Superclass,
			typeof(Field)
		)
		// make sure no duplicate fields in the hierarchy
		inheritedFields.forEach [
			inheritedField |
			for (field : fjAux.selectFields(cl)) {
				field.name != inheritedField.name
			}
		]
		
		var inheritedMethods = getAll(
			cl.superclass,
			FjPackage::eINSTANCE.class_Members,
			FjPackage::eINSTANCE.class_Superclass,
			typeof(Method)
		)
		// check override predicate
		inheritedMethods.forEach [
			inheritedMethod |
			fjAux.selectMethods(cl).forEach [
				G ||- it ~~ inheritedMethod
			]
		]
	}
}

checkrule CheckClassOk for
	Class clazz
from {
	empty |- clazz
}

checkrule CheckMain for
	Program program
from {
	program.main == null // nothing to check
	or
	empty |- program.main
}

checkrule CheckMethodBody for
	Method method
from {
}

checkrule CheckField for
	Field field
from {
}

checkrule CheckMethodOverride for
	Method method
from {

}

checkrule CheckClassHierachyNotCyclic for
	Class cl
from {
	if (cl.superclass != null) {
		!getAll(
			cl,
			FjPackage::eINSTANCE.class_Superclass,
			FjPackage::eINSTANCE.class_Superclass,
			typeof(Class)
		).contains(cl)
		or
		fail
			error "Cyclic hierarchy for " + cl.name
			source cl
	}
}
