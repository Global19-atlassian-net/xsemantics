import it.xsemantics.example.lambda.lambda.Abstraction
import it.xsemantics.example.lambda.lambda.Application
import it.xsemantics.example.lambda.lambda.Arithmetics
import it.xsemantics.example.lambda.lambda.ArrowType
import it.xsemantics.example.lambda.lambda.BasicType
import it.xsemantics.example.lambda.lambda.IntConstant
import it.xsemantics.example.lambda.lambda.IntType
import it.xsemantics.example.lambda.lambda.Parameter
import it.xsemantics.example.lambda.lambda.Program
import it.xsemantics.example.lambda.lambda.StringConstant
import it.xsemantics.example.lambda.lambda.StringType
import it.xsemantics.example.lambda.lambda.Term
import it.xsemantics.example.lambda.lambda.Type
import it.xsemantics.example.lambda.lambda.TypeVariable
import it.xsemantics.example.lambda.lambda.Variable
import it.xsemantics.example.lambda.validation.AbstractLambdaJavaValidator
import org.eclipse.emf.ecore.util.EcoreUtil

system it.xsemantics.example.lambda.xsemantics.LambdaXsemanticsSystem

validatorExtends AbstractLambdaJavaValidator

inject LambdaUtils lambdaUtils

auxiliary {
	notoccur(Type type, Type other)
		error stringRep(type) + " occurs in " + stringRep(other)
}

judgments {
	type |- TypeSubstitutions substitutions |> Term term : output Type
	paramtype |~ Parameter param : output Type
	typesubstitution |- TypeSubstitutions substitutions |> Type original ~> output Type
	unify |- TypeSubstitutions substitutions |> 
		Type originalLeft ~~ Type originalRight ~> output Type ~~ output Type
}

auxiliary notoccur(Type type, Type other) { true }

auxiliary notoccur(TypeVariable variable, TypeVariable other)
{
	variable.typevarName != other.typevarName
}

auxiliary notoccur(TypeVariable variable, ArrowType arrowType)
{
	notoccur(variable, arrowType.left)
	notoccur(variable, arrowType.right)
}

rule SubstituteType
	G |- TypeSubstitutions substitutions |> Type type ~> Type result
from {
	result = type
}

rule SubstituteTypeVariable
	G |- TypeSubstitutions substitutions |> TypeVariable variable ~> Type result
from {
	{
		var mapped = substitutions.mapped(variable.typevarName)
		mapped != null
		result = EcoreUtil::copy(mapped)
		G |- substitutions |> result ~> result // recursive
	}
	or
		result = variable
}

rule SubstituteArrowType
	G |- TypeSubstitutions substitutions |> ArrowType arrowType ~> ArrowType result
from {
	var Type subResult
	result = EcoreUtil::copy(arrowType)
	G |- substitutions |> arrowType.left ~> subResult
	result.left = subResult
	G |- substitutions |> arrowType.right ~> subResult
	result.right = subResult
}


rule UnifyType
	G |- TypeSubstitutions substitutions |>  Type t1 ~~ Type t2 ~> t1 ~~ t2
from {
	// in general it fails
	fail
}

axiom UnifyStringType
	G |- TypeSubstitutions substitutions |> StringType t1 ~~ StringType t2 
		~> EcoreUtil::copy(t1) ~~ EcoreUtil::copy(t2)

axiom UnifyIntType
	G |- TypeSubstitutions substitutions |> IntType t1 ~~ IntType t2 
		~> EcoreUtil::copy(t1) ~~ EcoreUtil::copy(t2)

rule UnifyTypeVariableBasicType
	G |- TypeSubstitutions substitutions |> TypeVariable typeVar ~~ BasicType basicType 
		~> EcoreUtil::copy(basicType) ~~ BasicType result
from {
	result = EcoreUtil::copy(basicType)
	substitutions.add(typeVar.typevarName, result)
}

rule UnifyBasicTypeTypeVariable
	G |- TypeSubstitutions substitutions |> BasicType basicType ~~ TypeVariable typeVar
		~> BasicType resultForVar ~~ BasicType resultForBasic
from {
	G |- substitutions |> typeVar ~~ basicType ~> resultForVar ~~ resultForBasic
}

rule UnifyTypeVariables
	G |- TypeSubstitutions substitutions |> TypeVariable originalLeft ~~ TypeVariable originalRight 
		~> TypeVariable newLeft ~~ TypeVariable newRight
from {
	// unify both variables with a fresh new variable
	newLeft = lambdaUtils.createFreshTypeVariable
	newRight = EcoreUtil::copy(newLeft)
	substitutions.add(originalLeft.typevarName, newLeft)
	substitutions.add(originalRight.typevarName, newRight)
}

rule UnifyTypeVariableArrowType
	G |- TypeSubstitutions substitutions |> TypeVariable originalLeft ~~ ArrowType originalRight 
		~> ArrowType newLeft ~~ EcoreUtil::copy(originalRight)
from {
	// occur check
	notoccur(originalLeft, originalRight)
	newLeft = EcoreUtil::copy(originalRight)
	substitutions.add(originalLeft.typevarName, newLeft)
}

rule UnifyArrowTypeTypeVariable
	G |- TypeSubstitutions substitutions |> ArrowType originalLeft ~~ TypeVariable originalRight 
		~> ArrowType newLeft ~~ ArrowType newRight
from {
	G |- substitutions |> originalRight ~~ originalLeft ~> newRight ~~ newLeft
}

rule UnifyArrowTypes
	G |- TypeSubstitutions substitutions |> ArrowType arrow1 ~~ ArrowType arrow2 
		~> ArrowType newArrow1 ~~ ArrowType newArrow2
from {
	newArrow1 = EcoreUtil::copy(arrow1)
	newArrow2 = EcoreUtil::copy(arrow2)
	var Type temp1
	var Type temp2
	G |- substitutions |> arrow1.left ~~ arrow2.left ~> temp1 ~~ temp2
	newArrow1.left = temp1
	newArrow2.left = temp2
	G |- substitutions |> arrow1.right ~~ arrow2.right ~> temp1 ~~ temp2
	newArrow1.right = temp1
	newArrow2.right = temp2
}

rule ParameterType
	G |~ Parameter param : Type type
from {
	{
		param.type != null
		type = EcoreUtil::copy(param.type)
	}
	or
	type = lambdaUtils.createFreshTypeVariable
}

axiom StringConstantType
	G |- TypeSubstitutions substitutions |> 
		StringConstant stringConstant : lambdaUtils.createStringType

axiom IntConstantType
	G |- TypeSubstitutions substitutions |> 
		IntConstant intConstant : lambdaUtils.createIntType

rule VariableType
	G |- TypeSubstitutions substitutions |> 
		Variable variable : Type type
from {
	G |- substitutions |> EcoreUtil::copy(env(G, variable.ref, Type)) ~> type
}

rule ArithmeticsType
	G |- TypeSubstitutions substitutions |> 
		Arithmetics arithmetics : IntType intType
from {
	intType = lambdaUtils.createIntType
	G |- substitutions |> arithmetics.term : var Type termType
	// the term type must be unifiable with int type
	G |- substitutions |> termType ~~ intType ~> intType ~~ intType
}

rule AbstractionType
	G |- TypeSubstitutions substitutions |> Abstraction abstraction : ArrowType type
from {
	G |~ abstraction.param : var Type paramType
	G, abstraction.param <- paramType |- 
		substitutions |> abstraction.term : var Type termType
	G |- substitutions |> paramType ~> paramType
	G |- substitutions |> termType ~> termType
	type = lambdaUtils.createArrowType(paramType, termType)
}

rule ApplicationType
	G |- TypeSubstitutions substitutions |> Application application : Type type
from {
	G |- substitutions |> application.fun : var Type funType
	
	// make sure funType can be unified ArrowType
	var arrowType = lambdaUtils.createFreshArrowType
	G |- substitutions |> funType ~~ arrowType ~> funType ~~ arrowType
	
	G |- substitutions |> application.arg : var Type argType
	
	// unify arrow left with the type of the argument
	G |- substitutions |> arrowType.left ~~ argType ~> funType ~~ argType
	
	// the result is the arrow right after substitutions
	G |- substitutions |> arrowType.right ~> type
}

checkrule CheckProgram for
	Program program
from {
	lambdaUtils.resetCounter
	// if we can type the program term
	empty |- new TypeSubstitutions() |> program.term : var Type type
}