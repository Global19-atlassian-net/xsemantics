<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >
<title>Examples</title>

<link href="book.css" rel="stylesheet" type="text/css">
<link href="code.css" rel="stylesheet" type="text/css">
<link rel="home" href="xtext.html" title="">
</head>
<body>
<a name="Examples"></a>
<h1>Examples</h1>
<p>
Now we will show some examples of Xsemantics systems (type systems and possibly
operation semantics/interpreter) for some languages implemented in Xtext.
</p>
<p>
The presented examples are available as an installable feature from the
update site.  Once installed, you will find project wizards for the example
languages.  If you want to inspect the sources, you can retrieve them
from the git repository (see <a href="02-GettingStarted.html#Sources" title="Go to &quot;Sources&quot;" >section Sources</a>).
</p>
<a name="Expressions"></a>
<h2>An Expression Language</h2>
<p>
Let us consider this Xtext implementation of an Expressions language
(similar to the <em>Arithmetic</em> example shipped with Xtext)
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">grammar</span>&nbsp;it.xsemantics.example.expressions.Expressions&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">with</span>&nbsp;org.eclipse.xtext.common.Terminals<br/>
<br/>
<span class="keyword">generate</span>&nbsp;expressions&nbsp;<span class="string">"http://xsemantics.sf.net/example/expressions/Expressions"</span><br/>
<br/>
Model:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(variables+=Variable)*<br/>
;<br/>
<br/>
Variable:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;name=ID&nbsp;<span class="string">&apos;=&apos;</span>&nbsp;expression=Expression<br/>
;<br/>
<br/>
Expression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;BooleanExpression;<br/>
<br/>
BooleanExpression&nbsp;<span class="keyword">returns</span>&nbsp;Expression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Comparison&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(({AndOrExpression.left=<span class="keyword">current</span>}&nbsp;op=(<span class="string">"||"</span>|<span class="string">"&amp;&amp;"</span>))&nbsp;right=Comparison)*;<br/>
<br/>
Comparison&nbsp;<span class="keyword">returns</span>&nbsp;Expression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Equals<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(({Comparison.left=<span class="keyword">current</span>}&nbsp;op=(<span class="string">"&lt;"</span>)&nbsp;)&nbsp;right=Equals)*;<br/>
<br/>
Equals&nbsp;<span class="keyword">returns</span>&nbsp;Expression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Addition&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(({Equals.left=<span class="keyword">current</span>}&nbsp;op=(<span class="string">"=="</span>)&nbsp;)&nbsp;right=Addition)*;<br/>
&nbsp;<br/>
Addition&nbsp;<span class="keyword">returns</span>&nbsp;Expression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Multiplication<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(({Plus.left=<span class="keyword">current</span>}&nbsp;<span class="string">&apos;+&apos;</span>&nbsp;|&nbsp;{Minus.left=<span class="keyword">current</span>}&nbsp;<span class="string">&apos;-&apos;</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;right=Multiplication)*;&nbsp;<br/>
<br/>
Multiplication&nbsp;<span class="keyword">returns</span>&nbsp;Expression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Prefixed&nbsp;(({MultiOrDiv.left=<span class="keyword">current</span>}&nbsp;op=(<span class="string">"*"</span>|<span class="string">"/"</span>))&nbsp;right=Prefixed)*;<br/>
<br/>
Prefixed&nbsp;<span class="keyword">returns</span>&nbsp;Expression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{BooleanNegation}&nbsp;=&gt;<span class="string">"!"</span>&nbsp;expression=Atomic&nbsp;|&nbsp;<span class="comment">/*&nbsp;right&nbsp;associativity&nbsp;*/</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{ArithmeticSigned}&nbsp;=&gt;<span class="string">"-"</span>&nbsp;expression=Atomic&nbsp;|&nbsp;<span class="comment">/*&nbsp;right&nbsp;associativity&nbsp;*/</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;Atomic;<br/>
<br/>
Atomic&nbsp;<span class="keyword">returns</span>&nbsp;Expression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;(&apos;</span>&nbsp;Expression&nbsp;<span class="string">&apos;)&apos;</span>&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{NumberLiteral}&nbsp;value=INT&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{StringLiteral}&nbsp;value=STRING&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{BooleanLiteral}&nbsp;value=(<span class="string">&apos;true&apos;</span>|<span class="string">&apos;false&apos;</span>)&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{VariableReference}&nbsp;ref=[Variable]<br/>
;<br/>
<br/>
<span class="comment">//&nbsp;the&nbsp;types&nbsp;will&nbsp;be&nbsp;used&nbsp;only&nbsp;internally&nbsp;by&nbsp;the&nbsp;type&nbsp;system<br/>
</span>Type:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{IntType}&nbsp;<span class="string">&apos;int&apos;</span>&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{StringType}&nbsp;<span class="string">&apos;string&apos;</span>&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{BooleanType}&nbsp;<span class="string">&apos;boolean&apos;</span><br/>
;<br/>
</p>
</div>
</div>
</p>
<p>
With this language you can write variable declarations assigning an
expression (you don&apos;t declare variable types); expressions can refer to
variables declared before the current variable (the scoping will take care of
this).
</p>
<p>
Note that, for the sake of simplicity, we do not consider a full
expression grammar, for instance, we only consider <span class="inlinecode">&lt;</span> as a comparison
operator.  This is just to keep this example simple and concentrate
on writing a type system and an interpreter with Xsemantics.
</p>
<p>
Now we would like to implement these checks:
</p>
<p>
<ul>
	<li>
		<span class="inlinecode">-&nbsp;/&nbsp;*</span> binary operators and <span class="inlinecode">-</span> unary operator
		act only on numeric expressions
	</li>
	<li>
		<span class="inlinecode">+</span> can act both on numeric expressions and on strings; if one
		of the operand is a string the whole expression will be a string
	</li>
	<li>
		<span class="inlinecode">==</span> operator acts only on expressions of the same type
	</li>
	<li>
		<span class="inlinecode">&lt;</span> operator acts only on numeric and string expressions,
		and the two subexpressions must be of the same type
	</li>
	<li>
		<span class="inlinecode">&amp;&amp;&nbsp;||</span> binary operators and <span class="inlinecode">!</span> unary operator
		act only on boolean expressions
	</li>
</ul>
</p>
<p>
So let&apos;s start writing the static semantics for the expressions language,
i.e., the type system.
</p>
<p>
Note that in the grammar we also have a definition for <span class="inlinecode">Type</span>, though
that rule will never be used in the grammar; we chose this way so that
we will have also the EClass definitions for the types that will be used
by the type system.  Of course, you could have simply define the hierarchy
for types using plain Java.
</p>
<a name="ExpressionsTS"></a>
<h3>Expressions Type System</h3>
<p>
Since we will extend the semantics of this language, we will start with
a first implementation (that is why we use "First" in the name of the system).
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">system</span>&nbsp;<span class="keyword">it</span>.xsemantics.example.expressions.typing.FirstExpressionsSemantics<br/>
<br/>
<span class="keyword">import</span>&nbsp;<span class="keyword">it</span>.xsemantics.example.expressions.expressions.*<br/>
<br/>
<span class="keyword">judgments</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;|-&nbsp;Expression&nbsp;expression&nbsp;:&nbsp;<span class="keyword">output</span>&nbsp;Type<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">error</span>&nbsp;<span class="string">"cannot&nbsp;type&nbsp;"</span>&nbsp;+&nbsp;stringRep(expression)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">source</span>&nbsp;expression<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;more&nbsp;judgments&nbsp;later<br/>
</span>}<br/>
</p>
</div>
</div>
</p>
<p>
So we define a judgment that we call <span class="inlinecode">type</span> which takes an
<span class="inlinecode">Expression</span> as input parameter and provides a <span class="inlinecode">Type</span> as
output.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">axiom</span>&nbsp;NumeralLiteral<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;NumberLiteral&nbsp;num&nbsp;:&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExpressionsFactory::eINSTANCE.createIntType<br/>
<br/>
<span class="keyword">axiom</span>&nbsp;BooleanLiteral<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;BooleanLiteral&nbsp;bool&nbsp;:&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExpressionsFactory::eINSTANCE.createBooleanType<br/>
<br/>
<span class="keyword">axiom</span>&nbsp;StringLiteral<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;StringLiteral&nbsp;str&nbsp;:&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExpressionsFactory::eINSTANCE.createStringType<br/>
</p>
</div>
</div>
</p>
<p>
For the constants, we can write axioms, which will simply return
an instance of the corresponding type.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;MultiOrDiv<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;MultiOrDiv&nbsp;multiOrDiv&nbsp;:&nbsp;IntType&nbsp;intType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;multiOrDiv.left&nbsp;:&nbsp;intType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;multiOrDiv.right&nbsp;:&nbsp;intType<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;Minus<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Minus&nbsp;minus&nbsp;:&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ExpressionsFactory::eINSTANCE.createIntType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;IntType&nbsp;intType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;minus.left&nbsp;:&nbsp;intType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;minus.right&nbsp;:&nbsp;intType<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
The rules for multiplication, division and minus are similar (we do not
have a base class for them all, so we need two rules); they both state
that the result type is an <span class="inlinecode">IntType</span>, provided that the subexpressions
have themselves an an <span class="inlinecode">IntType</span>.  They do this in two different
(equivalent) ways.
</p>
<p>
The first one states that the result is an <span class="inlinecode">IntType</span> which is the
result of the typing of the left and right subexpressions.  Remember
that for this judgment, the second parameter is an output parameter.
Basically, the second rule does the same, in a more explicit way, and
it does not bind the output result (which is created on the fly) to
the result of typing of the subexpressions (which, however, are
still required to have integer type, since we pass to the rule invocation
an <span class="inlinecode">IntType</span> as output argument).
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;Plus<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Plus&nbsp;plus&nbsp;:&nbsp;Type&nbsp;type<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;plus.left&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;leftType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;plus.right&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;rightType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(leftType&nbsp;<span class="keyword">instanceof</span>&nbsp;StringType&nbsp;||&nbsp;rightType&nbsp;<span class="keyword">instanceof</span>&nbsp;StringType)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;ExpressionsFactory::eINSTANCE.createStringType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(leftType&nbsp;<span class="keyword">instanceof</span>&nbsp;IntType&nbsp;&amp;&amp;&nbsp;rightType&nbsp;<span class="keyword">instanceof</span>&nbsp;IntType)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;leftType&nbsp;<span class="comment">//&nbsp;i.e.,&nbsp;IntType<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Remember that for the + operator we are willing to deal both
with strings (string concatenation) and with integers (standard arithmetic
sum); but, if one of the two subexpressions has <span class="inlinecode">StringType</span>
then we consider the whole plus expression as a string concatenation
and we give it type string.  From the premises, it should be clear
that, in case one of the subexpressions has boolean type, the
rule will fail.
</p>
<p>
Note that we use the operator <span class="inlinecode">or</span>, <a href="XsemanticsSyntax.html#Premises" title="Go to &quot;Premises&quot;">Section about premises</a>.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;Comparison<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Comparison&nbsp;comparison&nbsp;:&nbsp;ExpressionsFactory::eINSTANCE.createBooleanType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;comparison.left&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;leftType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;comparison.right&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;rightType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;cannot&nbsp;compare&nbsp;booleans<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;(leftType&nbsp;<span class="keyword">instanceof</span>&nbsp;IntType&nbsp;&amp;&amp;&nbsp;rightType&nbsp;<span class="keyword">instanceof</span>&nbsp;IntType)&nbsp;||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(leftType&nbsp;<span class="keyword">instanceof</span>&nbsp;StringType&nbsp;&amp;&amp;&nbsp;rightType&nbsp;<span class="keyword">instanceof</span>&nbsp;StringType)<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;Equals<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Equals&nbsp;comparison&nbsp;:&nbsp;ExpressionsFactory::eINSTANCE.createBooleanType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;comparison.left&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;leftType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;comparison.right&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;rightType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;can&nbsp;compare&nbsp;only&nbsp;if&nbsp;they&nbsp;have&nbsp;the&nbsp;same&nbsp;type<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;(leftType.eClass&nbsp;==&nbsp;rightType.eClass)<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
The code for <span class="inlinecode">Comparison</span> and <span class="inlinecode">Equals</span> are similar: they both
return a boolean type as a result; but while equality can be checked
with any type of expressions (provided the subexpressions have the
same type), the comparison (which, in our example, limits to
<span class="inlinecode">&lt;</span>) does not consider boolean subexpressions.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;BooleanNegation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;BooleanNegation&nbsp;negation&nbsp;:&nbsp;BooleanType&nbsp;boolType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;negation.expression&nbsp;:&nbsp;boolType<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;AndOr<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;AndOrExpression&nbsp;andOr&nbsp;:&nbsp;BooleanType&nbsp;boolType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;andOr.left&nbsp;:&nbsp;boolType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;andOr.right&nbsp;:&nbsp;boolType<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;ArithmeticSigned<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;ArithmeticSigned&nbsp;signed&nbsp;:&nbsp;ExpressionsFactory::eINSTANCE.createIntType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;signed.expression&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;IntType&nbsp;intType<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Now the rules for boolean negation, logical <span class="inlinecode">&amp;&amp;</span> and <span class="inlinecode">||</span> and the unary
arithmetic signed operations should be clear.
</p>
<a name="ExpressionsInfer"></a>
<h3>Type Inference for Variables</h3>
<p>
We need one more rule for typing expressions, in particular the one
for <span class="inlinecode">VariableReference</span>, whose type is the type of the referred variable.
But what is the type of a variable?  The idea is that we infer the type of
a variable from the type of its expression.
</p>
<p>
Since <span class="inlinecode">Variable</span> is not an <span class="inlinecode">Expression</span> in our grammar, we need
to introduce another judgment in our type system (an alternative would have
been to introduce in the grammar a rule introducing a common superclass
for both <span class="inlinecode">Variable</span> and <span class="inlinecode">Expression</span>, e.g., <span class="inlinecode">Typable</span>, 
and write the <span class="inlinecode">type</span> judgment with the first parameter of type <span class="inlinecode">Typable</span>).
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">judgments</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;<span class="comment">//&nbsp;as&nbsp;above...<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;vartype&nbsp;||-&nbsp;Variable&nbsp;variable&nbsp;:&nbsp;<span class="keyword">output</span>&nbsp;Type<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">error</span>&nbsp;<span class="string">"cannot&nbsp;type&nbsp;"</span>&nbsp;+&nbsp;stringRep(variable)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">source</span>&nbsp;variable<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">feature</span>&nbsp;ExpressionsPackage::eINSTANCE.variable_Expression<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Note that the new judgment has a different symbol w.r.t. the <span class="inlinecode">type</span>
judgment.  Moreover, when specifying the error for such judgments
we specify that the EObject for the error marker is the variable,
but the feature for the error marker is the variable&apos;s expression.
This will generate a better error marker.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;VariableReference<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;VariableReference&nbsp;varRef&nbsp;:&nbsp;Type&nbsp;type<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;||-&nbsp;varRef.ref&nbsp;:&nbsp;type<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;Variable<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;||-&nbsp;Variable&nbsp;variable&nbsp;:&nbsp;Type&nbsp;type<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;variable.expression&nbsp;!=&nbsp;<span class="keyword">null</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;variable.expression&nbsp;:&nbsp;type<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Now, the type rule for <span class="inlinecode">VariableReference</span> relies on the judgment
<span class="inlinecode">vartype</span>, which states that the type of a variable is the type
of its expression.
</p>
<p>
IMPORTANT: note that expressions can refer to other variables, and in
case of mutual dependencies like
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
i&nbsp;=&nbsp;j&nbsp;+&nbsp;10<br/>
j&nbsp;=&nbsp;i&nbsp;*5<br/>
</p>
</div>
</div>
</p>
<p>
the typing would enter an infinite loop!  For this reason, for this example
language we limited the scope of variables: expressions can refer only
to variables defined before the current expression.
</p>
<a name="ExpressionsValidation"></a>
<h3>Expressions Validation</h3>
<p>
Now that we have our type system for expressions we can write
validation rules (<a href="XsemanticsSyntax.html#CheckRules" title="Go to &quot;Rules for Validator: checkrule&quot;" >section CheckRules</a>):
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">checkrule</span>&nbsp;CheckVariable&nbsp;<span class="keyword">for</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;Variable&nbsp;variable<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">empty</span>&nbsp;||-&nbsp;variable&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;type<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
This simply checks that we can give a <span class="inlinecode">Variable</span> a type
(in an empty environment).
</p>
<p>
Please refer to <a href="XsemanticsSyntax.html#GeneratedValidator" title="Go to &quot;The Generated Java Validator&quot;" >section GeneratedValidator</a> to see how to use the generated
Java validator (which we also followed in the implementation of this
Expressions example language).
</p>
<a name="ExpressionsInterpreter"></a>
<h3>Interpreter for Expressions</h3>
<p>
Xsemantics can be used also to write interpreter rules (which can be
seen also as the operational semantics of the language).
</p>
<p>
For the Expressions language we thus introduce another judgment kind:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">judgments</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;<span class="comment">//&nbsp;as&nbsp;above...<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;interpret&nbsp;|-&nbsp;Expression&nbsp;expression&nbsp;~&gt;&nbsp;<span class="keyword">output</span>&nbsp;Object<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Note that we assume that we will run the interpreter ONLY on well-typed
Expressions program.
</p>
<p>
We then start writing the rules for this new judgment
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">axiom</span>&nbsp;InterpretNumberLiteral<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;NumberLiteral&nbsp;number&nbsp;~&gt;&nbsp;number.value<br/>
<br/>
<span class="keyword">axiom</span>&nbsp;InterpretStringLiteral<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;StringLiteral&nbsp;string&nbsp;~&gt;&nbsp;string.value<br/>
<br/>
<span class="keyword">axiom</span>&nbsp;InterpretBooleanLiteral<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;BooleanLiteral&nbsp;bool&nbsp;~&gt;&nbsp;Boolean::valueOf(bool.value)<br/>
</p>
</div>
</div>
</p>
<p>
The rules for literals are pretty straightforward; note only the case for
boolean literals: since the <span class="inlinecode">value</span> feature is a string, we need to
convert it to an actual boolean.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;InterpretMinus<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Minus&nbsp;plus&nbsp;~&gt;&nbsp;Integer&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;plus.left&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Integer&nbsp;leftResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;plus.right&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Integer&nbsp;rightResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftResult.intValue&nbsp;-&nbsp;rightResult.intValue<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;InterpretMultiOrDiv<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;MultiOrDiv&nbsp;multiOrDiv&nbsp;~&gt;&nbsp;Integer&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;multiOrDiv.left&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Integer&nbsp;leftResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;multiOrDiv.right&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Integer&nbsp;rightResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(multiOrDiv.op&nbsp;==&nbsp;<span class="string">&apos;*&apos;</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftResult.intValue&nbsp;*&nbsp;rightResult.intValue<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftResult.intValue&nbsp;/&nbsp;rightResult.intValue<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;InterpretArithmeticSigned<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;ArithmeticSigned&nbsp;signed&nbsp;~&gt;&nbsp;Integer&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;signed.expression&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Integer&nbsp;expResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;-(expResult)<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
The above rules rely on the fact that the result of subexpression is
an <span class="inlinecode">Integer</span>.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;InterpretAndOr<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;AndOrExpression&nbsp;andOr&nbsp;~&gt;&nbsp;Boolean&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;andOr.left&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Boolean&nbsp;leftResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;andOr.right&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Boolean&nbsp;rightResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(andOr.op&nbsp;==&nbsp;<span class="string">"&amp;&amp;"</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftResult.booleanValue&nbsp;&amp;&amp;&nbsp;rightResult.booleanValue<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftResult.booleanValue&nbsp;||&nbsp;rightResult.booleanValue<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;InterpretBooleanNegation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;BooleanNegation&nbsp;neg&nbsp;~&gt;&nbsp;Boolean&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;neg.expression&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Boolean&nbsp;expResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;!expResult<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Similarly in case of boolean expressions the result of subexpressions is
assumed to be a <span class="inlinecode">Boolean</span>.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;InterpretComparison<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Comparison&nbsp;comparison&nbsp;~&gt;&nbsp;Boolean&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;comparison.left&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Object&nbsp;leftResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;comparison.right&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Object&nbsp;rightResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(leftResult&nbsp;<span class="keyword">instanceof</span>&nbsp;String&nbsp;&amp;&amp;&nbsp;rightResult&nbsp;<span class="keyword">instanceof</span>&nbsp;String)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftResult.toString&nbsp;&lt;&nbsp;rightResult.toString<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;both&nbsp;are&nbsp;int&nbsp;if&nbsp;the&nbsp;expression&nbsp;is&nbsp;well-typed<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;(leftResult&nbsp;<span class="keyword">as</span>&nbsp;Integer)&nbsp;&lt;&nbsp;(rightResult&nbsp;<span class="keyword">as</span>&nbsp;Integer)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;InterpretEquals<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Equals&nbsp;comparison&nbsp;~&gt;&nbsp;Boolean&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;comparison.left&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Object&nbsp;leftResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;comparison.right&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Object&nbsp;rightResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftResult.toString&nbsp;==&nbsp;rightResult.toString<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
For comparison, the result will be a <span class="inlinecode">Boolean</span>; note that we check
whether the subexpressions are strings to convert them to a string representation
and compare such representation; the only other possible case is that they are
both integer (remember that we will call the interpreter only on well-typed
programs).  Note that for equality we simply convert the result of
subexpressions to string and compare the resulting string representation.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;InterpretPlus<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Plus&nbsp;plus&nbsp;~&gt;&nbsp;Object&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;plus.left&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Object&nbsp;leftResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;plus.right&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Object&nbsp;rightResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(leftResult&nbsp;<span class="keyword">instanceof</span>&nbsp;String&nbsp;||&nbsp;rightResult&nbsp;<span class="keyword">instanceof</span>&nbsp;String)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;leftString&nbsp;=&nbsp;leftResult.toString<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;rightString&nbsp;=&nbsp;rightResult.toString<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftString&nbsp;+&nbsp;rightString<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;<span class="keyword">else</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;both&nbsp;are&nbsp;int&nbsp;if&nbsp;the&nbsp;expression&nbsp;is&nbsp;well-typed<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;leftInt&nbsp;=&nbsp;leftResult&nbsp;<span class="keyword">as</span>&nbsp;Integer<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;rightInt&nbsp;=&nbsp;rightResult&nbsp;<span class="keyword">as</span>&nbsp;Integer<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftInt&nbsp;+&nbsp;rightInt<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;InterpretVariableRefenrence<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;VariableReference&nbsp;varRef&nbsp;~&gt;&nbsp;Object&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;varRef.ref.expression&nbsp;~&gt;&nbsp;result<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
At this point, the remaining above interpreter rules should be
straightforward.
</p>
<a name="ExpressionsCustomization"></a>
<h3>Customizations for Expressions</h3>
<p>
For the Expressions language we provide a custom implementation of
<abbr title="it.xsemantics.runtime.StringRepresentation" >StringRepresentation</abbr> (see also
<a href="XsemanticsSyntax.html#StringRepresentation" title="Go to &quot;String Representation&quot;" >section StringRepresentation</a>):
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;ExpressionsStringRepresentation&nbsp;<span class="keyword">extends</span>&nbsp;StringRepresentation&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">protected</span>&nbsp;String&nbsp;stringRep(String&nbsp;s)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="string">"&apos;"</span>&nbsp;+&nbsp;s&nbsp;+&nbsp;<span class="string">"&apos;"</span>;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
This way when a <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/lang/String.html" title="View JavaDoc"><abbr title="java.lang.String" >String</abbr></a> has to be represented by Xsemantics
generated code, it will add quotes around it; this way we are sure that we
are dealing with an actual string.
</p>
<a name="MoreInvolvedExpressionsSystem"></a>
<h3>A more involved Expressions System</h3>
<p>
Now, let&apos;s complicate things a bit, and make the system for our
Expressions language more powerful, with this new requirement:
we want to be able to implicitly convert string literals to numbers
and booleans when this is possible.  This way, if an expression requires
the subexpressions to be numbers or booleans we can also accept string literals
if they can be convertible.  
(Note that we intentionally avoided to consider the number literal
<span class="inlinecode">0</span> as <span class="inlinecode">false</span> and a number literal different from <span class="inlinecode">0</span>
as <span class="inlinecode">true</span>, but you can extend the system further if you want).
Thus, we want the following expressions to be
valid (and interpreted accordingly with an implicit conversion):
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
i&nbsp;=&nbsp;20&nbsp;-&nbsp;<span class="string">&apos;5&apos;</span>&nbsp;<span class="comment">//&nbsp;OK!&nbsp;can&nbsp;be&nbsp;given&nbsp;int&nbsp;type&nbsp;and&nbsp;evaluates&nbsp;to&nbsp;15<br/>
</span>b&nbsp;=&nbsp;(i&nbsp;&gt;&nbsp;20)&nbsp;||&nbsp;<span class="string">&apos;true&apos;</span>&nbsp;<span class="comment">//&nbsp;OK!&nbsp;can&nbsp;be&nbsp;given&nbsp;boolean&nbsp;type<br/>
</span><span class="comment">//&nbsp;and&nbsp;evaluates&nbsp;to&nbsp;true&nbsp;<br/>
</span>
</p>
</div>
</div>
</p>
<p>
Note that in case no expectation on types is expressed, the system
will be behave as before:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
i&nbsp;=&nbsp;20&nbsp;+&nbsp;<span class="string">&apos;5&apos;</span>&nbsp;<span class="comment">//&nbsp;has&nbsp;string&nbsp;type&nbsp;and&nbsp;evaluates&nbsp;to&nbsp;&apos;205&apos;<br/>
</span>j&nbsp;=&nbsp;(20&nbsp;*&nbsp;1)&nbsp;+&nbsp;<span class="string">&apos;5&apos;</span>&nbsp;<span class="comment">//&nbsp;has&nbsp;string&nbsp;type&nbsp;again<br/>
</span>k&nbsp;=&nbsp;20&nbsp;*&nbsp;(1&nbsp;+&nbsp;<span class="string">&apos;5&apos;</span>)&nbsp;<span class="comment">//&nbsp;has&nbsp;int&nbsp;type,&nbsp;since&nbsp;*&nbsp;requires&nbsp;int&nbsp;types<br/>
</span><span class="comment">//&nbsp;on&nbsp;subexpressions<br/>
</span>
</p>
</div>
</div>
</p>
<p>
Thus, we introduce a new judgment in our system
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">judgments</span>{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;as&nbsp;above<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;coerce&nbsp;|~&nbsp;Expression&nbsp;expression&nbsp;|&gt;&nbsp;Type&nbsp;expectedType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">error</span>&nbsp;<span class="string">"cannot&nbsp;convert&nbsp;"</span>&nbsp;+&nbsp;stringRep(expression)&nbsp;+<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"&nbsp;to&nbsp;type&nbsp;"</span>&nbsp;+&nbsp;stringRep(expectedType)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">source</span>&nbsp;expression<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
We then have to define the rules for this new judgment:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;StringToInt<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|~&nbsp;StringLiteral&nbsp;string&nbsp;|&gt;&nbsp;IntType&nbsp;type<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Integer::parseInt(string.value)<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;StringToBool<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|~&nbsp;StringLiteral&nbsp;string&nbsp;|&gt;&nbsp;BooleanType&nbsp;type<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;string.value.equalsIgnoreCase(<span class="string">"true"</span>)&nbsp;||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;string.value.equalsIgnoreCase(<span class="string">"false"</span>)<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Then, this judgment will be used by the other rules; in particular, we need to
modify some rules we have seen so far.
</p>
<p>
The idea is that, as hinted above, that rules that expect a subexpression to
be of a specific type should "communicate" this expectation through the
rule environment (refer to <a href="XsemanticsSyntax.html#Environment" title="Go to &quot;Rule Environment&quot;" >section Environment</a>), by mapping the string
<span class="inlinecode"><span class="string">&apos;expected&apos;</span></span> to the expected type.
</p>
<p>
With this assumption, we change the rule for <span class="inlinecode">StringLiteral</span>, since its
type now depends on the above expectation:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;StringLiteral<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;StringLiteral&nbsp;str&nbsp;:&nbsp;Type&nbsp;resultType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;expected&nbsp;=&nbsp;<span class="keyword">env</span>(G,&nbsp;<span class="string">&apos;expected&apos;</span>,&nbsp;Type)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|~&nbsp;str&nbsp;|&gt;&nbsp;expected<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultType&nbsp;=&nbsp;expected<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultType&nbsp;=&nbsp;ExpressionsFactory::eINSTANCE.createStringType<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
The first block of the <span class="inlinecode">or</span> can fail due to the fact that
</p>
<p>
<ul>
	<li>
		No expectation was requested or
	</li>
	<li>
		the expectation cannot be satisfied
	</li>
</ul>
</p>
<p>
In any other case the type will be <span class="inlinecode">string</span> (which might make invoking
rules fail).
</p>
<p>
Now we need to adapt those rules that have expectations on subexpressions,
in order to pass to rule invocation an appropriate environment:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;MultiOrDiv<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;MultiOrDiv&nbsp;multiOrDiv&nbsp;:&nbsp;IntType&nbsp;intType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;intType&nbsp;=&nbsp;ExpressionsFactory::eINSTANCE.createIntType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G,&nbsp;<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;intType&nbsp;|-&nbsp;multiOrDiv.left&nbsp;:&nbsp;intType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G,&nbsp;<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;intType&nbsp;|-&nbsp;multiOrDiv.right&nbsp;:&nbsp;intType<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;AndOr<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;AndOrExpression&nbsp;andOr&nbsp;:&nbsp;BooleanType&nbsp;boolType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;boolType&nbsp;=&nbsp;ExpressionsFactory::eINSTANCE.createBooleanType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G,&nbsp;<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;boolType&nbsp;|-&nbsp;andOr.left&nbsp;:&nbsp;boolType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G,&nbsp;<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;boolType&nbsp;|-&nbsp;andOr.right&nbsp;:&nbsp;boolType<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
We only showed two examples (the other rules for expected int and boolean
types are updated accordingly).
</p>
<p>
Note that in cases where no expectation is required, we now need to
pass an empty environment when typing subexpressions, otherwise we might
reject well-typed expressions due to expectations that were passed to the
current rule upon invocation.  This is the case of comparison:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;Comparison<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Comparison&nbsp;comparison&nbsp;:&nbsp;ExpressionsFactory::eINSTANCE.createBooleanType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">empty</span>&nbsp;|-&nbsp;comparison.left&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;leftType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">empty</span>&nbsp;|-&nbsp;comparison.right&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;rightType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(leftType&nbsp;<span class="keyword">instanceof</span>&nbsp;IntType&nbsp;&amp;&amp;&nbsp;rightType&nbsp;<span class="keyword">instanceof</span>&nbsp;IntType)&nbsp;||<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(leftType&nbsp;<span class="keyword">instanceof</span>&nbsp;StringType&nbsp;&amp;&amp;&nbsp;rightType&nbsp;<span class="keyword">instanceof</span>&nbsp;StringType)<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
The rule for Plus now is a little bit more complex, since it
has to take care of possible expectations:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;Plus<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Plus&nbsp;plus&nbsp;:&nbsp;Type&nbsp;type<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;plus.left&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;leftType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;plus.right&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;TyThe&nbsp;-e&nbsp;option&nbsp;is&nbsp;not&nbsp;standard.&nbsp;A&nbsp;POSIX-compliant&nbsp;echo&nbsp;does&nbsp;not&nbsp;accept&nbsp;any&nbsp;options:pe&nbsp;rightType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;expected&nbsp;=&nbsp;<span class="keyword">env</span>(G,&nbsp;<span class="string">&apos;expected&apos;</span>,&nbsp;Type)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|~&nbsp;plus.left&nbsp;|&gt;&nbsp;expected<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|~&nbsp;plus.right&nbsp;|&gt;&nbsp;expected<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;expected<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(leftType&nbsp;<span class="keyword">instanceof</span>&nbsp;StringType&nbsp;||&nbsp;rightType&nbsp;<span class="keyword">instanceof</span>&nbsp;StringType)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;ExpressionsFactory::eINSTANCE.createStringType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(leftType&nbsp;<span class="keyword">instanceof</span>&nbsp;IntType&nbsp;&amp;&amp;&nbsp;rightType&nbsp;<span class="keyword">instanceof</span>&nbsp;IntType)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;=&nbsp;leftType&nbsp;<span class="comment">//&nbsp;i.e.,&nbsp;IntType<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Now we need to adapt also some interpretation rules to take into
consideration expectations:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;InterpretStringLiteral<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;StringLiteral&nbsp;string&nbsp;~&gt;&nbsp;Object&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;expected<br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected&nbsp;=&nbsp;<span class="keyword">env</span>(G,&nbsp;<span class="string">&apos;expected&apos;</span>,&nbsp;IntType)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;Integer::parseInt(string.value)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expected&nbsp;=&nbsp;<span class="keyword">env</span>(G,&nbsp;<span class="string">&apos;expected&apos;</span>,&nbsp;BooleanType)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;Boolean::parseBoolean(string.value)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;string.value<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;InterpretMultiOrDiv<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;MultiOrDiv&nbsp;multiOrDiv&nbsp;~&gt;&nbsp;Integer&nbsp;result<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;IntType&nbsp;intType&nbsp;=&nbsp;ExpressionsFactory::eINSTANCE.createIntType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G,&nbsp;<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;intType&nbsp;|-&nbsp;multiOrDiv.left&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Integer&nbsp;leftResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G,&nbsp;<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;intType&nbsp;|-&nbsp;multiOrDiv.right&nbsp;~&gt;&nbsp;<span class="keyword">var</span>&nbsp;Integer&nbsp;rightResult<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(multiOrDiv.op&nbsp;==&nbsp;<span class="string">&apos;*&apos;</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftResult.intValue&nbsp;*&nbsp;rightResult.intValue<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;leftResult.intValue&nbsp;/&nbsp;rightResult.intValue<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Again, we only showed some modified rules; now it should be clear what
other rules need to be adapted and how.
</p>
<a name="ExpressionsCodeGeneration"></a>
<h3>Generation for Expressions</h3>
<p>
The Expressions language we used in this example does not implement any
real code generation.  However, we implemented a generation strategy just
for the sake of demonstration on how to use the generated Java code
and the trace utilities.
</p>
<p>
The generator will generate an <span class="inlinecode">.output</span> file which shows
the type for each variable, the interpretation of its expression, together
with the application traces (as strings) both for the type and the interpretation.
The relevant part of the generator (written in Xtend2) is shown:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">class</span>&nbsp;ExpressionsGenerator&nbsp;<span class="keyword">implements</span>&nbsp;IGenerator&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@Inject&nbsp;ExpressionsSemantics&nbsp;semantics<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@Inject&nbsp;<span class="keyword">extension</span>&nbsp;TraceUtils<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@Inject&nbsp;<span class="keyword">extension</span>&nbsp;StringRepresentation<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;skipped&nbsp;some&nbsp;code<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">def</span>&nbsp;compileExpression(Expression&nbsp;exp)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;typeTrace&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;RuleApplicationTrace()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;interpreterTrace&nbsp;=&nbsp;<span class="keyword">new</span>&nbsp;RuleApplicationTrace()<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;type&nbsp;=&nbsp;semantics.type(null,&nbsp;typeTrace,&nbsp;exp)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;result&nbsp;=&nbsp;semantics.interpret(null,&nbsp;interpreterTrace,&nbsp;exp)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;&apos;</span><span class="string">&apos;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type:&nbsp;&laquo;type.value.string&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;trace:&nbsp;&laquo;typeTrace.traceAsString&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interpretation:&nbsp;&laquo;result.value.string&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;interpretation&nbsp;trace:&nbsp;&laquo;interpreterTrace.traceAsString&raquo;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&apos;</span><span class="string">&apos;&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
<span class="inlinecode">ExpressionSemantics</span> is the Java class generated by Xsemantics from
the system we wrote for the Expressions language.
Note that <span class="inlinecode">string</span> and <span class="inlinecode">traceAsString</span> come from
<abbr title="it.xsemantics.runtime.StringRepresentation" >StringRepresentation</abbr> and
<abbr title="it.xsemantics.runtime.util.TraceUtils" >TraceUtils</abbr> respectively, and they
are used as extension methods.
</p>
<p>
Thus, starting from this expression:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
myString&nbsp;=&nbsp;<span class="string">&apos;foo&apos;</span>&nbsp;+&nbsp;10&nbsp;+&nbsp;false<br/>
</p>
</div>
</div>
</p>
<p>
we get this output:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
Variable:&nbsp;myString<br/>
type:&nbsp;StringType<br/>
type&nbsp;trace:&nbsp;<br/>
Plus:&nbsp;[]&nbsp;|-&nbsp;<span class="string">&apos;foo&apos;</span>&nbsp;+&nbsp;10&nbsp;+&nbsp;false&nbsp;:&nbsp;StringType<br/>
&nbsp;Plus:&nbsp;[]&nbsp;|-&nbsp;<span class="string">&apos;foo&apos;</span>&nbsp;+&nbsp;10&nbsp;:&nbsp;StringType<br/>
&nbsp;&nbsp;StringLiteral:&nbsp;[]&nbsp;|-&nbsp;<span class="string">&apos;foo&apos;</span>&nbsp;:&nbsp;StringType<br/>
&nbsp;&nbsp;NumeralLiteral:&nbsp;[]&nbsp;|-&nbsp;10&nbsp;:&nbsp;IntType<br/>
&nbsp;BooleanLiteral:&nbsp;[]&nbsp;|-&nbsp;false&nbsp;:&nbsp;BooleanType<br/>
<br/>
interpretation:&nbsp;<span class="string">&apos;foo10false&apos;</span><br/>
interpretation&nbsp;trace:&nbsp;<br/>
InterpretPlus:&nbsp;[]&nbsp;|-&nbsp;<span class="string">&apos;foo&apos;</span>&nbsp;+&nbsp;10&nbsp;+&nbsp;false&nbsp;~&gt;&nbsp;<span class="string">&apos;foo10false&apos;</span><br/>
&nbsp;InterpretPlus:&nbsp;[]&nbsp;|-&nbsp;<span class="string">&apos;foo&apos;</span>&nbsp;+&nbsp;10&nbsp;~&gt;&nbsp;<span class="string">&apos;foo10&apos;</span><br/>
&nbsp;&nbsp;InterpretStringLiteral:&nbsp;[]&nbsp;|-&nbsp;<span class="string">&apos;foo&apos;</span>&nbsp;~&gt;&nbsp;<span class="string">&apos;foo&apos;</span><br/>
&nbsp;&nbsp;InterpretNumberLiteral:&nbsp;[]&nbsp;|-&nbsp;10&nbsp;~&gt;&nbsp;10<br/>
&nbsp;InterpretBooleanLiteral:&nbsp;[]&nbsp;|-&nbsp;false&nbsp;~&gt;&nbsp;false<br/>
</p>
</div>
</div>
</p>
<p>
Note that the indentation represents the stack of invoked rules.
The quotes around string literals come from our customization of
<abbr title="it.xsemantics.runtime.StringRepresentation" >StringRepresentation</abbr>, see <a href="Examples.html#ExpressionsCustomization" title="Go to &quot;Customizations for Expressions&quot;" >section ExpressionsCustomization</a>.
Moreover <span class="inlinecode">[]</span> represents an empty environment.
</p>
<p>
A more involved example including variable references and
implicit coercions is
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
intVar&nbsp;=&nbsp;1<br/>
intVar2&nbsp;=&nbsp;2&nbsp;*&nbsp;(intVar&nbsp;+&nbsp;<span class="string">&apos;1&apos;</span>)<br/>
</p>
</div>
</div>
</p>
<p>
which produces the following output
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
Variable:&nbsp;intVar2<br/>
type:&nbsp;IntType<br/>
type&nbsp;trace:&nbsp;<br/>
MultiOrDiv:&nbsp;[]&nbsp;|-&nbsp;2&nbsp;*&nbsp;(intVar&nbsp;+&nbsp;<span class="string">&apos;1&apos;</span>)&nbsp;:&nbsp;IntType<br/>
&nbsp;NumeralLiteral:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;2&nbsp;:&nbsp;IntType<br/>
&nbsp;Plus:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;intVar&nbsp;+&nbsp;<span class="string">&apos;1&apos;</span>&nbsp;:&nbsp;IntType<br/>
&nbsp;&nbsp;VariableReference:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;intVar&nbsp;:&nbsp;IntType<br/>
&nbsp;&nbsp;&nbsp;Variable:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;||-&nbsp;intVar&nbsp;=&nbsp;1&nbsp;:&nbsp;IntType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;NumeralLiteral:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;1&nbsp;:&nbsp;IntType<br/>
&nbsp;&nbsp;StringLiteral:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;<span class="string">&apos;1&apos;</span>&nbsp;:&nbsp;IntType<br/>
&nbsp;&nbsp;&nbsp;StringToInt:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|~&nbsp;<span class="string">&apos;1&apos;</span>&nbsp;|&gt;&nbsp;IntType<br/>
<br/>
interpretation:&nbsp;4<br/>
interpretation&nbsp;trace:&nbsp;<br/>
InterpretMultiOrDiv:&nbsp;[]&nbsp;|-&nbsp;2&nbsp;*&nbsp;(intVar&nbsp;+&nbsp;<span class="string">&apos;1&apos;</span>)&nbsp;~&gt;&nbsp;4<br/>
&nbsp;InterpretNumberLiteral:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;2&nbsp;~&gt;&nbsp;2<br/>
&nbsp;InterpretPlus:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;intVar&nbsp;+&nbsp;<span class="string">&apos;1&apos;</span>&nbsp;~&gt;&nbsp;2<br/>
&nbsp;&nbsp;InterpretVariableRefenrence:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;intVar&nbsp;~&gt;&nbsp;1<br/>
&nbsp;&nbsp;&nbsp;InterpretNumberLiteral:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;1&nbsp;~&gt;&nbsp;1<br/>
&nbsp;&nbsp;InterpretStringLiteral:&nbsp;[<span class="string">&apos;expected&apos;</span>&nbsp;&lt;-&nbsp;IntType]&nbsp;|-&nbsp;<span class="string">&apos;1&apos;</span>&nbsp;~&gt;&nbsp;1<br/>
</p>
</div>
</div>
</p>
<a name="FJ"></a>
<h2>Featherweight Java</h2>
<p>
Featherweight Java is a lightweight functional version of Java, 
which focuses on a few basic features. It is not intended to be used as
a programming language, but as a formal framework for studying properties 
of Java (A. Igarashi, B. Pierce, and P.Wadler. <em>Featherweight Java: a 
minimal core calculus for Java and GJ</em>. ACM TOPLAS, 23(3):396-450, 2001.). 
In this section we will see how to write the type system of FJ using Xsemantics.
(As future work we will also define the operational semantics of FJ in Xsemantics.)
</p>
<a name="FJInANutshell"></a>
<h3>FJ in a nutshell</h3>
<p>
FJ focuses on the following features: 
mutually recursive class definitions, inheritance, object creation, 
method invocation, method recursion through this, subtyping and field access. 
In particular, a FJ program is a list of class definitions and a single 
main expression.
Here&apos;s an example of an FJ program:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">class</span>&nbsp;A&nbsp;<span class="keyword">extends</span>&nbsp;Object&nbsp;{&nbsp;}<br/>
<span class="keyword">class</span>&nbsp;B&nbsp;<span class="keyword">extends</span>&nbsp;Object&nbsp;{&nbsp;}<br/>
<br/>
<span class="keyword">class</span>&nbsp;Pair&nbsp;<span class="keyword">extends</span>&nbsp;Object&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;fst;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Object&nbsp;snd;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Pair&nbsp;setfst(Object&nbsp;newfst)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;Pair(newfst,&nbsp;<span class="keyword">this</span>.snd);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;Pair&nbsp;setsnd(Object&nbsp;newscd)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;Pair(<span class="keyword">this</span>.fst,&nbsp;newscd);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
<br/>
<span class="keyword">new</span>&nbsp;Pair(<span class="keyword">new</span>&nbsp;A(),&nbsp;<span class="keyword">new</span>&nbsp;B()).setfst(<span class="keyword">new</span>&nbsp;A()).fst<br/>
</p>
</div>
</div>
</p>
<p>
Since in FJ the class constructor has a fixed shape, we consider a 
simplified version of the language by assuming constructors as implicit; 
in particular when invoking <span class="inlinecode">new</span> we should pass an argument for each field 
in the class, including inherited fields, in the same order of the hierarchy. 
Thus, if we have the following classes
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">class</span>&nbsp;A&nbsp;{&nbsp;<span class="keyword">int</span>&nbsp;i;&nbsp;<span class="keyword">boolean</span>&nbsp;b;&nbsp;}<br/>
<span class="keyword">class</span>&nbsp;B&nbsp;<span class="keyword">extends</span>&nbsp;A&nbsp;{&nbsp;String&nbsp;s;&nbsp;}<br/>
</p>
</div>
</div>
</p>
<p>
we must create an instance of <span class="inlinecode">B2</span> as follows: 
<span class="inlinecode"><span class="keyword">new</span>&nbsp;B(10,&nbsp;true,&nbsp;<span class="string">"foo"</span>)</span>.
</p>
<a name="FJInXtext"></a>
<h3>FJ implemented in Xtext</h3>
<p>
We had already implemented FJ in Xtext (that implementation can be found at 
<a href="http://fj-eclipse.sourceforge.net">http://fj-eclipse.sourceforge.net</a>).  
In that implementation, the type system was implemented directly in Java.  
With Xsemantics we ship another implementation of FJ where the type system is 
written using Xsemantics instead of manually written Java code.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">grammar</span>&nbsp;it.xsemantics.example.fj.FJ&nbsp;<span class="keyword">with</span>&nbsp;org.eclipse.xtext.common.Terminals<br/>
<br/>
<span class="keyword">generate</span>&nbsp;fj&nbsp;<span class="string">"http://xsemantics.sf.net/example/fj/FJ"</span><br/>
<br/>
Program&nbsp;:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(classes&nbsp;+=&nbsp;Class)*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(main&nbsp;=&nbsp;Expression)?&nbsp;;<br/>
<br/>
Type:&nbsp;BasicType&nbsp;|&nbsp;ClassType;<br/>
<br/>
BasicType&nbsp;:&nbsp;basic=(<span class="string">&apos;int&apos;</span>&nbsp;|&nbsp;<span class="string">&apos;boolean&apos;</span>&nbsp;|&nbsp;<span class="string">&apos;String&apos;</span>);<br/>
<br/>
ClassType&nbsp;:&nbsp;classref=[Class];<br/>
<br/>
Class:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;class&apos;</span>&nbsp;name=ID&nbsp;(<span class="string">&apos;extends&apos;</span>&nbsp;superclass=[Class])?&nbsp;<span class="string">&apos;{&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(members&nbsp;+=&nbsp;Member)*<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;}&apos;</span>&nbsp;;<br/>
<br/>
Member:&nbsp;Field&nbsp;|&nbsp;Method;<br/>
<br/>
Field:&nbsp;type=Type&nbsp;name=ID&nbsp;<span class="string">&apos;;&apos;</span>&nbsp;;<br/>
<br/>
Method:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type=Type&nbsp;name=ID&nbsp;<span class="string">&apos;(&apos;</span>&nbsp;(params+=Parameter&nbsp;(<span class="string">&apos;,&apos;</span>&nbsp;params+=Parameter)*)?&nbsp;<span class="string">&apos;)&apos;</span>&nbsp;<span class="string">&apos;{&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;body=MethodBody<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;}&apos;</span>&nbsp;;<br/>
<br/>
Parameter:&nbsp;type=Type&nbsp;name=ID&nbsp;;<br/>
<br/>
TypedElement:&nbsp;Member&nbsp;|&nbsp;Parameter;<br/>
<br/>
MethodBody:&nbsp;<span class="string">&apos;return&apos;</span>&nbsp;expression=Expression&nbsp;<span class="string">&apos;;&apos;</span>&nbsp;;<br/>
<br/>
Expression:<br/>
&nbsp;&nbsp;&nbsp;&nbsp;TerminalExpression&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;=&gt;(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{Selection.receiver=<span class="keyword">current</span>}&nbsp;<span class="string">&apos;.&apos;</span>&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message=[Member]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="string">&apos;(&apos;</span>&nbsp;(args+=Expression&nbsp;(<span class="string">&apos;,&apos;</span>&nbsp;args+=Expression)*)?&nbsp;<span class="string">&apos;)&apos;</span>)?<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)*&nbsp;;<br/>
<br/>
TerminalExpression&nbsp;<span class="keyword">returns</span>&nbsp;Expression:<br/>
&nbsp;&nbsp;&nbsp;This&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;ParamRef&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;New&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;=&gt;Cast&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;Constant&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;Paren&nbsp;;<br/>
<br/>
This:&nbsp;variable=<span class="string">&apos;this&apos;</span>;<br/>
ParamRef:&nbsp;parameter=[Parameter];<br/>
New:&nbsp;<span class="string">&apos;new&apos;</span>&nbsp;type=ClassType&nbsp;<span class="string">&apos;(&apos;</span>&nbsp;(args+=Expression&nbsp;(<span class="string">&apos;,&apos;</span>&nbsp;args+=Expression)*)?&nbsp;<span class="string">&apos;)&apos;</span>;<br/>
Cast:&nbsp;<span class="string">&apos;(&apos;</span>&nbsp;type=ClassType&nbsp;<span class="string">&apos;)&apos;</span>&nbsp;expression=TerminalExpression;<br/>
Paren&nbsp;<span class="keyword">returns</span>&nbsp;Expression:&nbsp;<span class="string">&apos;(&apos;</span>&nbsp;Expression&nbsp;<span class="string">&apos;)&apos;</span>;&nbsp;<br/>
<br/>
Constant:&nbsp;IntConstant&nbsp;|&nbsp;BoolConstant&nbsp;|&nbsp;StringConstant;<br/>
<br/>
StringConstant:&nbsp;constant=STRING;<br/>
<br/>
IntConstant:&nbsp;constant=INT;<br/>
<br/>
BoolConstant:&nbsp;constant&nbsp;=&nbsp;(<span class="string">&apos;true&apos;</span>&nbsp;|&nbsp;<span class="string">&apos;false&apos;</span>);<br/>
</p>
</div>
</div>
</p>
<a name="FJTypeSystem"></a>
<h3>FJ Type System</h3>
<p>
We start by defining the name (we skip imports) and the judgments
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">system</span>&nbsp;<span class="keyword">it</span>.xsemantics.example.fj.typing.FjTypeSystem<br/>
<br/>
<span class="keyword">judgments</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;type&nbsp;|-&nbsp;Expression&nbsp;expression&nbsp;:&nbsp;<span class="keyword">output</span>&nbsp;Type<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">error</span>&nbsp;<span class="string">"cannot&nbsp;type&nbsp;"</span>&nbsp;+&nbsp;stringRep(expression)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">source</span>&nbsp;expression<br/>
&nbsp;&nbsp;&nbsp;&nbsp;classtype&nbsp;|~&nbsp;Expression&nbsp;expression&nbsp;:&nbsp;<span class="keyword">output</span>&nbsp;ClassType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">error</span>&nbsp;stringRep(expression)&nbsp;+&nbsp;<span class="string">"&nbsp;has&nbsp;not&nbsp;a&nbsp;class&nbsp;type"</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">source</span>&nbsp;expression<br/>
&nbsp;&nbsp;&nbsp;&nbsp;subtype&nbsp;|-&nbsp;Type&nbsp;left&nbsp;&lt;:&nbsp;Type&nbsp;right<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">error</span>&nbsp;stringRep(left)&nbsp;+&nbsp;<span class="string">"&nbsp;is&nbsp;not&nbsp;a&nbsp;subtype&nbsp;of&nbsp;"</span>&nbsp;+&nbsp;stringRep(right)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;assignable&nbsp;|-&nbsp;Expression&nbsp;expression&nbsp;&lt;|&nbsp;Type&nbsp;right<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">error</span>&nbsp;stringRep(expression)&nbsp;+&nbsp;<span class="string">"&nbsp;is&nbsp;not&nbsp;assignable&nbsp;for&nbsp;"</span>&nbsp;+&nbsp;stringRep(right)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">source</span>&nbsp;expression<br/>
&nbsp;&nbsp;&nbsp;&nbsp;equalstype&nbsp;|-&nbsp;Type&nbsp;left&nbsp;~~&nbsp;Type&nbsp;right<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">error</span>&nbsp;stringRep(left)&nbsp;+&nbsp;<span class="string">"&nbsp;is&nbsp;not&nbsp;the&nbsp;same&nbsp;type&nbsp;as&nbsp;"</span>&nbsp;+&nbsp;stringRep(right)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;overrides&nbsp;||-&nbsp;Method&nbsp;current&nbsp;~~&nbsp;Method&nbsp;previous<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">error</span>&nbsp;current.name&nbsp;+&nbsp;<span class="string">"&nbsp;does&nbsp;not&nbsp;override&nbsp;the&nbsp;superclass&nbsp;method"</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">source</span>&nbsp;current<br/>
&nbsp;&nbsp;&nbsp;&nbsp;subtypesequence&nbsp;|-&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;owner&nbsp;~&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;Expression&gt;&nbsp;expressions&nbsp;&lt;&lt;&nbsp;List&lt;?&nbsp;extends&nbsp;TypedElement&gt;&nbsp;elements<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">error</span>&nbsp;<span class="string">"invalid&nbsp;arguments&nbsp;for&nbsp;expected&nbsp;parameters"</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">source</span>&nbsp;owner<br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="FJTyping"></a>
<h4>Typing FJ Expressions</h4>
<p>
Let&apos;s start with simple expressions
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">axiom</span>&nbsp;TParamRef&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;ParamRef&nbsp;paramref&nbsp;:&nbsp;paramref.parameter.type<br/>
<br/>
<span class="comment">//&nbsp;you&nbsp;can&nbsp;manually&nbsp;create&nbsp;the&nbsp;BasicType&nbsp;with&nbsp;EMF&nbsp;FjFactory...<br/>
</span><span class="keyword">axiom</span>&nbsp;TStringConstant<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;StringConstant&nbsp;s&nbsp;:&nbsp;{&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;result&nbsp;=&nbsp;FjFactory::eINSTANCE.createBasicType();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.basic&nbsp;=&nbsp;<span class="string">&apos;String&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
<span class="comment">//&nbsp;...or&nbsp;use&nbsp;static&nbsp;utility&nbsp;methods...<br/>
</span><span class="keyword">axiom</span>&nbsp;TIntConstant<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;IntConstant&nbsp;i&nbsp;:&nbsp;FjTypeUtils::createIntType<br/>
<br/>
<span class="comment">//&nbsp;...or&nbsp;closures<br/>
</span><span class="keyword">axiom</span>&nbsp;TBoolConstant<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;BoolConstant&nbsp;b&nbsp;:&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;[&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">it</span>.basic=<span class="string">&apos;boolean&apos;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">it</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;].apply(FjFactory::eINSTANCE.createBasicType())<br/>
</p>
</div>
</div>
</p>
<p>
The type of a parameter reference is simply the type of the referred
parameter (since <span class="inlinecode">Parameter</span> is an element with an explicit type).
</p>
<p>
Just to show the syntax of rules in Xsemantics which rely on Xbase,
we present above three different ways of creating the basic types (initialized
with the corresponding string).  This is just a demonstration: probably, the
best way is relying on static utility methods implemented for your DSL
(as we did with <span class="inlinecode">FjTypeUtils</span>).  Alternatively, as we did with the
Expressions example (see <a href="Examples.html#Expressions" title="Go to &quot;An Expression Language&quot;" >section Expressions</a>), we could have a different
class for each basic type.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;TNew<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;New&nbsp;newExp&nbsp;:&nbsp;newExp.type<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;fields&nbsp;=&nbsp;getAll(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newExp.type.classref,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FjPackage::eINSTANCE.class_Members,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FjPackage::eINSTANCE.class_Superclass,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">typeof</span>(Field)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;we&nbsp;want&nbsp;the&nbsp;superclasses&apos;&nbsp;fields&nbsp;first<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;Collections::reverse(fields)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;newExp&nbsp;~&gt;&nbsp;newExp.args&nbsp;&lt;&lt;&nbsp;fields<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
The type of a <span class="inlinecode">New</span> expression is the classtype mentioned in the expression
itself (e.g., the type of the expression <span class="inlinecode"><span class="keyword">new</span>&nbsp;C()</span> is <span class="inlinecode">C</span>).
However, we must also check that the expression is well-typed, i.e., that
all the arguments passed to the new expression are subtypes of the corresponding
fields of the classtype (see <a href="Examples.html#FJInANutshell" title="Go to &quot;FJ in a nutshell&quot;" >section FJInANutshell</a> for the syntax of constructors
in our implementation of FJ).  In order to collect all the fields of the
given class (including the inherited ones), we use the predefined
function <span class="inlinecode">getAll</span> (see <a href="XsemanticsSyntax.html#GetAll" title="Go to &quot;Graph Closures (getAll)&quot;" >section GetAll</a>).  The above invocation of <span class="inlinecode">getAll</span>
requires to collect all the <span class="inlinecode">Member</span>s in the class specified in the new
expressions, and recursively the ones found following the superclass, and
filter them in order to get only the <span class="inlinecode">Member</span>s which are <span class="inlinecode">Field</span>.
Remember that <span class="inlinecode">getAll</span> avoids possible loops in the class hierarchy
(see also <a href="Examples.html#FJValidation" title="Go to &quot;FJ Validation&quot;" >section FJValidation</a>).  Once we collected the fields we reverse
the list (using <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/Collections.html" title="View JavaDoc"><abbr title="java.util.Collections" >Collections</abbr></a> standard static method) so
that the superclass fields appear first in the list, and we check that
the types of the arguments are subtypes of the types of these fields
(we use the judgment <span class="inlinecode">subtypesequence</span>, described in <a href="Examples.html#FJSubTyping" title="Go to &quot;FJ Subtyping&quot;" >section FJSubTyping</a>).
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;TCast<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Cast&nbsp;cast&nbsp;:&nbsp;cast.type<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;cast.expression&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;expType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;cast.type&nbsp;&lt;:&nbsp;expType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;expType&nbsp;&lt;:&nbsp;cast.type<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
A cast expression, statically, is well-typed if the type of the object and the type we cast to are related,
and has the type of the type we cast to.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;TSelection<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Selection&nbsp;selection&nbsp;:&nbsp;selection.message.type<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;selection.receiver&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;ClassType&nbsp;receiverType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;check&nbsp;message&nbsp;if&nbsp;it&apos;s&nbsp;a&nbsp;method&nbsp;call<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;message&nbsp;=&nbsp;selection.message<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">switch</span>&nbsp;(message)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Method:&nbsp;{&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;selection&nbsp;~&gt;&nbsp;selection.args&nbsp;&lt;&lt;&nbsp;message.params<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
The type of the selection is the type of the selected <span class="inlinecode">Message</span>
(which refers to a <span class="inlinecode">Member</span>).
However, we must check that the received of the message is well-typed,
and in particular that it has a class type (since message selection,
i.e., field access or method invocation, is allowed only on class instances).
We perform this check by using as the output argument a <span class="inlinecode">ClassType</span>
(thus, that rule invocation would fail if the receiver had a basic type).
</p>
<p>
Furthermore, if the message refers to a <span class="inlinecode">Method</span>, we must
check that the arguments types are subtypes of the method parameters
(we use the judgment <span class="inlinecode">subtypesequence</span>, described in <a href="Examples.html#FJSubTyping" title="Go to &quot;FJ Subtyping&quot;" >section FJSubTyping</a>).
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">axiom</span>&nbsp;TThis<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;This&nbsp;_this&nbsp;:&nbsp;<span class="keyword">env</span>(G,&nbsp;<span class="string">&apos;this&apos;</span>,&nbsp;ClassType)<br/>
</p>
</div>
</div>
</p>
<p>
For the type of <span class="inlinecode"><span class="keyword">this</span></span> we use the predefined function <span class="inlinecode">env</span> 
(see <a href="XsemanticsSyntax.html#Environment" title="Go to &quot;Rule Environment&quot;" >section Environment</a>) which returns the value contained in the environment (first parameter of <span class="inlinecode">env</span>)
which corresponds to the passed key (<span class="inlinecode"><span class="string">&apos;this&apos;</span></span> in this case), provided the mapped
value is a <span class="inlinecode">ClassType</span>.  
The function <span class="inlinecode">env</span> fails (and thus makes the rule fail) if no mapping for the specified
key is found in the environment.  Who puts the mapping for <span class="inlinecode"><span class="string">&apos;this&apos;</span></span> in the environment?
We&apos;ll see that later (<a href="Examples.html#FJScoping" title="Go to &quot;FJ Scoping&quot;" >section FJScoping</a> and <a href="Examples.html#FJValidation" title="Go to &quot;FJ Validation&quot;" >section FJValidation</a>).
However, we assume that if this rule fails it is because we are trying to type <span class="inlinecode"><span class="keyword">this</span></span>
from outside a method body (e.g., in the program&apos;s main expression). 
</p>
<a name="FJScoping"></a>
<h4>FJ Scoping</h4>
<p>
We use the generated system from the rules defined in Xsemantics in the
scope provider, in particular for the scope of the members in
a <span class="inlinecode">Selection</span> expression: we need the type of the receiver to
know which members are visible in that selection expression:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">public</span>&nbsp;<span class="keyword">class</span>&nbsp;FJScopeProvider&nbsp;<span class="keyword">extends</span>&nbsp;AbstractDeclarativeScopeProvider&nbsp;{<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@Inject&nbsp;FjTypeSystem&nbsp;typeSystem;<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;@Override<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">public</span>&nbsp;IScope&nbsp;getScope(EObject&nbsp;context,&nbsp;EReference&nbsp;reference)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(reference&nbsp;==&nbsp;FjPackage.Literals.SELECTION__MESSAGE)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(context&nbsp;<span class="keyword">instanceof</span>&nbsp;Selection)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Selection&nbsp;selection&nbsp;=&nbsp;(Selection)&nbsp;context;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;Scopes<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.scopeFor(FjAuxiliaryFunctions<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.getMembers(getExpressionClass(selection<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.getReceiver())));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;IScope.NULLSCOPE;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">super</span>.getScope(context,&nbsp;reference);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">protected</span>&nbsp;Class&nbsp;getExpressionClass(Expression&nbsp;receiver)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClassType&nbsp;classType&nbsp;=&nbsp;typeSystem.classtype(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;environmentForExpression(receiver),&nbsp;receiver).getValue();<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;(classType&nbsp;!=&nbsp;null&nbsp;?&nbsp;classType.getClassref()&nbsp;:&nbsp;null);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">private</span>&nbsp;RuleEnvironment&nbsp;environmentForExpression(Expression&nbsp;expression)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class&nbsp;containingClass&nbsp;=&nbsp;EcoreUtil2.getContainerOfType(expression,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Class.<span class="keyword">class</span>);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(containingClass&nbsp;!=&nbsp;null)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ClassType&nbsp;thisType&nbsp;=&nbsp;FjTypeUtils.createClassType(containingClass);<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;<span class="keyword">new</span>&nbsp;RuleEnvironment(typeSystem.environmentEntry(<span class="string">"this"</span>,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;thisType));<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">return</span>&nbsp;null;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
In order to get the type of the receiver expression we use the generated
system (refer to <a href="XsemanticsSyntax.html#GeneratedSystem" title="Go to &quot;The Generated Java Rule System&quot;" >section GeneratedSystem</a>).  However, we need to provide
a binding for <span class="inlinecode"><span class="keyword">this</span></span> in the environment (see <a href="Examples.html#FJTyping" title="Go to &quot;Typing FJ Expressions&quot;" >section FJTyping</a>),
thus we build a <abbr title="it.xsemantics.runtime.RuleEnvironment" >RuleEnvironment</abbr> (see
also <a href="XsemanticsSyntax.html#Environment" title="Go to &quot;Rule Environment&quot;" >section Environment</a>) where we associate the string <span class="inlinecode"><span class="string">"this"</span></span> to
the class which contains the current selection expression.
</p>
<p>
Note that we do not use the <span class="inlinecode">type</span> judgment, but the judgment
<span class="inlinecode">classtype</span> (refer to <a href="Examples.html#FJTypeSystem" title="Go to &quot;FJ Type System&quot;" >section FJTypeSystem</a>) which already returns
a <span class="inlinecode">ClassType</span> as the output
parameter.  This judgment has only one simple rule which relies on
the <span class="inlinecode">type</span> judgment, but using as the output argument a <span class="inlinecode">ClassType</span>:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;TExpressionClassType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|~&nbsp;Expression&nbsp;expression&nbsp;:&nbsp;ClassType&nbsp;classType<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;expression&nbsp;:&nbsp;classType<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Once we have the class type of the receiver, we simply use an
auxiliary function to collect all the members of that class.
</p>
<a name="FJSubTyping"></a>
<h4>FJ Subtyping</h4>
<p>
We have a judgment <span class="inlinecode">subtype</span> which given a <span class="inlinecode">left</span> and <span class="inlinecode">right</span>
arguments succeeds if the former is a subtype of the latter.  Here are the
rules for this judgment:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;GeneralSubtyping<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Type&nbsp;left&nbsp;&lt;:&nbsp;Type&nbsp;right<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">error</span>&nbsp;<span class="string">"types&nbsp;"</span>&nbsp;+&nbsp;stringRep(left)&nbsp;+&nbsp;<span class="string">"&nbsp;and&nbsp;"</span>&nbsp;+&nbsp;stringRep(right)&nbsp;+<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"&nbsp;are&nbsp;not&nbsp;comparable"</span><br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;if&nbsp;we&nbsp;get&nbsp;here&nbsp;we&apos;re&nbsp;trying&nbsp;to&nbsp;mix<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;a&nbsp;BasicType&nbsp;with&nbsp;a&nbsp;ClassType,&nbsp;thus,&nbsp;we&nbsp;fail<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">fail</span><br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;BasicSubtyping<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">derives</span>&nbsp;G&nbsp;|-&nbsp;BasicType&nbsp;left&nbsp;&lt;:&nbsp;BasicType&nbsp;right<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;left.basic.equals(right.basic)<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;ClassSubtyping<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">derives</span>&nbsp;G&nbsp;|-&nbsp;ClassType&nbsp;left&nbsp;&lt;:&nbsp;ClassType&nbsp;right<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;left.classref&nbsp;==&nbsp;right.classref<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;right.classref.name&nbsp;==&nbsp;<span class="string">"Object"</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getAll(left.classref,&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FjPackage::eINSTANCE.class_Superclass,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FjPackage::eINSTANCE.class_Superclass,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">typeof</span>(Class))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.contains(right.classref)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
The general case always fails, since we cannot mix basic and class types.
Then for basic types we do not have actual subtyping, thus the two
basic types must be the same.  For class types we have three possible
cases:
</p>
<p>
<ol>
	<li>
		the two classes are the same (class subtyping is reflexive)
	</li>
	<li>
		the right class is <span class="inlinecode">Object</span> (every class is implicitly subclass of <span class="inlinecode">Object</span>)
	</li>
	<li>
		The right class is a parent of the left class (class subtyping is transitive);
		in order to check this last case, we get all the classes in the class
		hierarchy of the left class (using <span class="inlinecode">getAll</span>, <a href="XsemanticsSyntax.html#GetAll" title="Go to &quot;Graph Closures (getAll)&quot;" >section GetAll</a>), and use the
		standard Java <a class="jdoc" href="http://download.oracle.com/javase/1.5.0/docs/api/java/util/List.html" title="View JavaDoc"><abbr title="java.util.List" >List</abbr></a> <span class="inlinecode">contains</span> method
	</li>
</ol>
</p>
<p>
Remember that, since <span class="inlinecode">ClassType</span> has a reference to an actual
<span class="inlinecode">Class</span> object, it is safe to use object identities.
</p>
<p>
We also have a <span class="inlinecode">assignable</span> judgment which tells whether an
<span class="inlinecode">Expression</span> is assignable to a type, by getting the type of
of the expression and then checking the subtyping:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;ExpressionAssignableToType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Expression&nbsp;expression&nbsp;&lt;|&nbsp;Type&nbsp;right<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;expressionType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;expression&nbsp;:&nbsp;expressionType<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;expressionType&nbsp;&lt;:&nbsp;right<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Since in the typing rules for expressions (see <a href="Examples.html#FJTyping" title="Go to &quot;Typing FJ Expressions&quot;" >section FJTyping</a>) we
have to check whether arguments are subtypes of parameters (in the
<span class="inlinecode">New</span> and <span class="inlinecode">Selection</span> rules) we isolate a specific judgment
<span class="inlinecode">subtypesequence</span>, that we recall here
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">judgments</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;...<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;subtypesequence&nbsp;|-&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Expression&nbsp;owner&nbsp;~&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;Expression&gt;&nbsp;expressions&nbsp;&lt;&lt;&nbsp;List&lt;?&nbsp;extends&nbsp;TypedElement&gt;&nbsp;elements<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">error</span>&nbsp;<span class="string">"invalid&nbsp;arguments&nbsp;for&nbsp;expected&nbsp;parameters"</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">source</span>&nbsp;owner<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
whose (single rule) is implemented as follows:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;SubtypeSequence&nbsp;<span class="keyword">derives</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Expression&nbsp;owner&nbsp;~&gt;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;List&lt;Expression&gt;&nbsp;expressions&nbsp;&lt;&lt;&nbsp;List&lt;TypedElement&gt;&nbsp;typedElements<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;expressions.size&nbsp;==&nbsp;typedElements.size<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">fail</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">error</span>&nbsp;<span class="string">"expected&nbsp;"</span>&nbsp;+&nbsp;typedElements.size&nbsp;+&nbsp;<span class="string">"&nbsp;arguments,&nbsp;but&nbsp;got&nbsp;"</span>&nbsp;+<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expressions.size<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">source</span>&nbsp;owner&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;typedElementsIterator&nbsp;=&nbsp;typedElements.iterator<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;(exp&nbsp;:&nbsp;expressions)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;exp&nbsp;&lt;|&nbsp;typedElementsIterator.next.type<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
First of all, the sizes of the two collections must be the same;
if this first check fails we explicitly fail (see <a href="XsemanticsSyntax.html#ExplicitFailure" title="Go to &quot;Explicit Failure&quot;" >section ExplicitFailure</a>)
with an informative error; in order to make the error really informative
and, most of all, to make the error marker generation effective
(see <a href="XsemanticsSyntax.html#ErrorGeneration" title="Go to &quot;Error Marker Generation&quot;" >section ErrorGeneration</a>), we need the "owner" of this check, i.e.,
the expression context where this check has to be carried out, in order
to specify that expression as the source of the error (<a href="XsemanticsSyntax.html#ErrorSpecification" title="Go to &quot;Error Specification&quot;" >section ErrorSpecification</a>).
Compare this with the way this judgment is used in the typing of
<span class="inlinecode">New</span> and <span class="inlinecode">Selection</span> (<a href="Examples.html#FJTyping" title="Go to &quot;Typing FJ Expressions&quot;" >section FJTyping</a>).  If this first check
succeeds, we check that every expression is a subtype of the corresponding
type; in order to do this we rely on <span class="inlinecode">assignable</span> statement,
described before.
</p>
<p>
We also have the judgment <span class="inlinecode">equalstype</span> for type equality,
similar to <span class="inlinecode">subtype</span>, which will be used in check rules for
validation (<a href="Examples.html#FJValidation" title="Go to &quot;FJ Validation&quot;" >section FJValidation</a>):
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;GeneralEquals<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;Type&nbsp;left&nbsp;~~&nbsp;Type&nbsp;right<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">error</span>&nbsp;<span class="string">"types&nbsp;"</span>&nbsp;+&nbsp;stringRep(left)&nbsp;+&nbsp;<span class="string">"&nbsp;and&nbsp;"</span>&nbsp;+&nbsp;stringRep(right)&nbsp;+<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"&nbsp;are&nbsp;not&nbsp;comparable"</span><br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;if&nbsp;we&nbsp;get&nbsp;here&nbsp;we&apos;re&nbsp;trying&nbsp;to&nbsp;mix<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;a&nbsp;BasicType&nbsp;with&nbsp;a&nbsp;ClassType,&nbsp;thus,&nbsp;we&nbsp;fail<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">fail</span><br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;BasicEquals<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">derives</span>&nbsp;G&nbsp;|-&nbsp;BasicType&nbsp;left&nbsp;~~&nbsp;BasicType&nbsp;right<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;left.basic.equals(right.basic)<br/>
}<br/>
<br/>
<span class="keyword">rule</span>&nbsp;ClassEquals<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">derives</span>&nbsp;G&nbsp;|-&nbsp;ClassType&nbsp;left&nbsp;~~&nbsp;ClassType&nbsp;right<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;left.classref&nbsp;==&nbsp;right.classref<br/>
}<br/>
</p>
</div>
</div>
</p>
<a name="FJValidation"></a>
<h4>FJ Validation</h4>
<p>
We define some checkrules (<a href="XsemanticsSyntax.html#CheckRules" title="Go to &quot;Rules for Validator: checkrule&quot;" >section CheckRules</a>) for validating an FJ program.
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">checkrule</span>&nbsp;CheckMethodBody&nbsp;<span class="keyword">for</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;method<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;typeForThis&nbsp;=&nbsp;FjTypeUtils::createClassType(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;EcoreUtil2::getContainerOfType(method,&nbsp;<span class="keyword">typeof</span>(Class))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">&apos;this&apos;</span>&nbsp;&lt;-&nbsp;typeForThis&nbsp;|-&nbsp;method.body.expression&nbsp;&lt;|&nbsp;method.type<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
This rule checks that the return expression of a method body is
a subtype of the declared method&apos;s type.  It relies on the
judgment <span class="inlinecode">assignable</span> seen in <a href="Examples.html#FJSubTyping" title="Go to &quot;FJ Subtyping&quot;" >section FJSubTyping</a>.  However,
since this will involve being able to type possible occurrences
of <span class="inlinecode">this</span> we must also pass an explicit envrionment (<a href="XsemanticsSyntax.html#Environment" title="Go to &quot;Rule Environment&quot;" >section Environment</a>)
with a mapping for <span class="inlinecode"><span class="string">&apos;this&apos;</span></span> (mapped to the class type of the class
containing the method).  This is similar to what we do for FJ scoping
(<a href="Examples.html#FJScoping" title="Go to &quot;FJ Scoping&quot;" >section FJScoping</a>).
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">checkrule</span>&nbsp;CheckField&nbsp;<span class="keyword">for</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;Field&nbsp;field<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;clazz&nbsp;=&nbsp;field.eContainer&nbsp;<span class="keyword">as</span>&nbsp;Class<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(clazz.superclass&nbsp;!=&nbsp;<span class="keyword">null</span>)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;inheritedFields&nbsp;=&nbsp;getAll(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clazz.superclass,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FjPackage::eINSTANCE.class_Members,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FjPackage::eINSTANCE.class_Superclass,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">typeof</span>(Field)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;make&nbsp;sure&nbsp;no&nbsp;duplicate&nbsp;fields&nbsp;in&nbsp;the&nbsp;hierarchy<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;(inheritedField&nbsp;:&nbsp;inheritedFields)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(field.name&nbsp;==&nbsp;inheritedField.name)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">fail</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">error</span>&nbsp;<span class="string">"field&nbsp;already&nbsp;declared&nbsp;in&nbsp;superclass&nbsp;"</span>&nbsp;+<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringRep(inheritedField.eContainer)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
For a <span class="inlinecode">Field</span> we must check that a field with the same name
is not defined in the superclasses (for fields with the same name in the
same class this check is already done by Xtext predefined
<a class="jdoc" href="http://download.eclipse.org/modeling/tmf/xtext/javadoc/2.2.0/org/eclipse/xtext/validation/NamesAreUniqueValidator.html" title="View JavaDoc"><abbr title="org.eclipse.xtext.validation.NamesAreUniqueValidator" >NamesAreUniqueValidator</abbr></a> <a class="srcLink" href="https://github.com/eclipse/xtext/blob/v2.2.0/plugins/org.eclipse.xtext/src/org/eclipse/xtext/validation/NamesAreUniqueValidator.java" title="View Source Code" >(src)</a>).
Again, to get all the fields in a class hierarchy we use <span class="inlinecode">getAll</span>
(<a href="XsemanticsSyntax.html#GetAll" title="Go to &quot;Graph Closures (getAll)&quot;" >section GetAll</a>).
</p>
<p>
For methods we cannot execute the same check, since subclasses
are allowed to redefine methods, provided they keep the same signature
(in FJ covariance of return type is not allowed); thus we defined a
specific judgment, <span class="inlinecode">overrides</span>, whose only rule is defined
as follows:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">rule</span>&nbsp;MethodOverride<br/>
&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;||-&nbsp;Method&nbsp;current&nbsp;~~&nbsp;Method&nbsp;previous<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;current.name&nbsp;!=&nbsp;previous.name<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;current.type&nbsp;~~&nbsp;previous.type<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">fail</span>&nbsp;<span class="keyword">error</span>&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="string">"cannot&nbsp;change&nbsp;return&nbsp;type&nbsp;of&nbsp;inherited&nbsp;method:&nbsp;"</span>&nbsp;+<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;stringRep(previous.type)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">source</span>&nbsp;current<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">feature</span>&nbsp;FjPackage::eINSTANCE.typedElement_Type<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;current.params.size&nbsp;==&nbsp;previous.params.size<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;previousParamsIt&nbsp;=&nbsp;previous.params.iterator<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">for</span>&nbsp;(param&nbsp;:&nbsp;current.params)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G&nbsp;|-&nbsp;param.type&nbsp;~~&nbsp;previousParamsIt.next.type<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Which basically says that a method correctly overrides another
one if their names are different (no actual overriding to check)
or if they have exactly the same signature (relying on judgment
<span class="inlinecode">equalstype</span>).
</p>
<p>
Thus, the checkrule for <span class="inlinecode">Method</span> is
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">checkrule</span>&nbsp;CheckMethodOverride&nbsp;<span class="keyword">for</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;Method&nbsp;method<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">val</span>&nbsp;clazz&nbsp;=&nbsp;method.eContainer&nbsp;<span class="keyword">as</span>&nbsp;Class<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(clazz.superclass&nbsp;!=&nbsp;<span class="keyword">null</span>)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">var</span>&nbsp;inheritedMethods&nbsp;=&nbsp;getAll(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;clazz.superclass,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FjPackage::eINSTANCE.class_Members,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FjPackage::eINSTANCE.class_Superclass,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">typeof</span>(Method)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">//&nbsp;check&nbsp;override&nbsp;predicate<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inheritedMethods.forEach&nbsp;[<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inheritedMethod&nbsp;|<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FjAuxiliaryFunctions::selectMethods(clazz).forEach&nbsp;[<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">empty</span>&nbsp;||-&nbsp;<span class="keyword">it</span>&nbsp;~~&nbsp;inheritedMethod<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
Note the use of Xbase closure (please refer to <a href="XsemanticsSyntax.html#ExpressionsInPremises" title="Go to &quot;Expressions in Premises&quot;" >section ExpressionsInPremises</a>
for the way Xsemantics interprets boolean expressions inside premises and
closures).
</p>
<p>
For a <span class="inlinecode">Class</span> we need to check that its superclass hierarchy is
not cyclic:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">checkrule</span>&nbsp;CheckClassHierachyNotCyclic&nbsp;<span class="keyword">for</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;Class&nbsp;cl<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">if</span>&nbsp;(cl.superclass&nbsp;!=&nbsp;<span class="keyword">null</span>)&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;!getAll(<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cl,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FjPackage::eINSTANCE.class_Superclass,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FjPackage::eINSTANCE.class_Superclass,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">typeof</span>(Class)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;).contains(cl)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">fail</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">error</span>&nbsp;<span class="string">"Cyclic&nbsp;hierarchy&nbsp;for&nbsp;"</span>&nbsp;+&nbsp;cl.name<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">source</span>&nbsp;cl<br/>
&nbsp;&nbsp;&nbsp;&nbsp;}<br/>
}<br/>
</p>
</div>
</div>
</p>
<p>
which basically checks that the current class is not in the
superclasses of itself.  Remember that using <span class="inlinecode">getAll</span> (<a href="XsemanticsSyntax.html#GetAll" title="Go to &quot;Graph Closures (getAll)&quot;" >section GetAll</a>)
avoids infinite loops in cases of cycles in the AST.
</p>
<p>
Finally, we check that we can give a type to the main expression
of an FJ program, in the empty environment:
</p>
<p>
<div class="literallayout">
<div class="incode">
<p class="code">
<span class="keyword">checkrule</span>&nbsp;CheckMain&nbsp;<span class="keyword">for</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;Program&nbsp;program<br/>
<span class="keyword">from</span>&nbsp;{<br/>
&nbsp;&nbsp;&nbsp;&nbsp;program.main&nbsp;==&nbsp;<span class="keyword">null</span>&nbsp;<span class="comment">//&nbsp;nothing&nbsp;to&nbsp;check<br/>
</span>&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">or</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="keyword">empty</span>&nbsp;|-&nbsp;program.main&nbsp;:&nbsp;<span class="keyword">var</span>&nbsp;Type&nbsp;mainType<br/>
}<br/>
</p>
</div>
</div>

</p>
<a name="Lambda"></a>
<h2>Lambda</h2>
<p>
<div class="todo" >
WRITE THIS Section
</div>
</p>
</body>
</html>
