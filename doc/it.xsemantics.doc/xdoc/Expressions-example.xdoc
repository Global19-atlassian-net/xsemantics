section:Expressions[An Expression Language]

Let us consider this Xtext implementation of an Expressions language
(similar to the e[Arithmetic] example shipped with Xtext)

code[Xtext][
grammar it.xsemantics.example.expressions.Expressions 
	with org.eclipse.xtext.common.Terminals

generate expressions "http://xsemantics.sf.net/example/expressions/Expressions"

Model:
	(variables+=Variable)*
;

Variable:
	name=ID '=' expression=Expression
;

Expression:
	BooleanExpression;

BooleanExpression returns Expression:
	Comparison 
	(({AndOrExpression.left=current} op=("||"|"&&")) right=Comparison)*;

Comparison returns Expression:
       Equals
       (({Comparison.left=current} op=("<") ) right=Equals)*;

Equals returns Expression:
       Addition 
       (({Equals.left=current} op=("==") ) right=Addition)*;
 
Addition returns Expression:
	Multiplication
	(({Plus.left=current} '+' | {Minus.left=current} '-')
		right=Multiplication)*; 

Multiplication returns Expression:
	Prefixed (({MultiOrDiv.left=current} op=("*"|"/")) right=Prefixed)*;

Prefixed returns Expression:
	{BooleanNegation} =>"!" expression=Atomic | /* right associativity */
	{ArithmeticSigned} =>"-" expression=Atomic | /* right associativity */
	Atomic;

Atomic returns Expression:
	'(' Expression ')' |
	{NumberLiteral} value=INT |
	{StringLiteral} value=STRING |
	{BooleanLiteral} value=('true'|'false') |
	{VariableReference} ref=\[Variable\]
;

// the types will be used only internally by the type system
Type:
	{IntType} 'int' |
	{StringType} 'string' |
	{BooleanType} 'boolean'
;
]

With this language you can write variable declarations assigning an
expression (you don't declare variable types); expressions can refer to
variables declared before the current variable (the scoping will take care of
this).

Note that, for the sake of simplicity, we do not consider a full
expression grammar, for instance, we only consider code[<] as a comparison
operator.  This is just to keep this example simple and concentrate
on writing a type system and an interpreter with Xsemantics.

Now we would like to implement these checks:

ul[
item[code[- / *] binary operators and code[-] unary operator
act only on numeric expressions]
item[code[+] can act both on numeric expressions and on strings; if one
of the operand is a string the whole expression will be a string]
item[code[==] operator acts only on expressions of the same type]
item[code[<] operator acts only on numeric and string expressions,
and the two subexpressions must be of the same type]
item[code[&& ||] binary operators and code[!] unary operator
act only on boolean expressions]
]

So let's start writing the static semantics for the expressions language,
i.e., the type system.

Note that in the grammar we also have a definition for code[Type], though
that rule will never be used in the grammar; we chose this way so that
we will have also the EClass definitions for the types that will be used
by the type system.  Of course, you could have simply define the hierarchy
for types using plain Java.

section2:ExpressionsTS[Expressions Type System]

Since we will extend the semantics of this language, we will start with
a first implementation (that is why we use "First" in the name of the system).

code[Xsemantics][
system it.xsemantics.example.expressions.typing.FirstExpressionsSemantics

import it.xsemantics.example.expressions.expressions.*

judgments {
	type |- Expression expression : output Type
	// more judgments later
}
]

So we define a judgment that we call code[type] which takes an
code[Expression] as input parameter and provides a code[Type] as
output.

code[Xsemantics][
axiom NumeralLiteral
	G |- NumberLiteral num : 
		ExpressionsFactory::eINSTANCE.createIntType

axiom BooleanLiteral
	G |- BooleanLiteral bool : 
		ExpressionsFactory::eINSTANCE.createBooleanType

axiom StringLiteral
	G |- StringLiteral str : 
		ExpressionsFactory::eINSTANCE.createStringType
]

For the constants, we can write axioms, which will simply return
an instance of the corresponding type.

code[Xsemantics][
rule MultiOrDiv
	G |- MultiOrDiv multiOrDiv : IntType intType
from {
	G |- multiOrDiv.left : intType
	G |- multiOrDiv.right : intType
}

rule Minus
	G |- Minus minus : 
		ExpressionsFactory::eINSTANCE.createIntType
from {
	var IntType intType
	G |- minus.left : intType
	G |- minus.right : intType
}
]