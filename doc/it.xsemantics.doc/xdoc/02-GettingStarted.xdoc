chapter:GettingStarted[Getting Started]

section:Install[Installation of Xsemantics]

To get started, you should first install Xsemantics plugins;
you can use the update site:
link[http://xsemantics.sourceforge.net/updatesite][http://xsemantics.sourceforge.net/updatesite]

section:UsingXsemantics[Using Xsemantics]

Before you start using Xsemantics for your Xtext language, you
should add in your plugin project the following dependency:
code[it.xsemantics.runtime].

To check whether your settings work correctly,

ol[
	item[you can create an Xtext project,
accepting the defaults;]
	item[add the dependency
code[it.xsemantics.runtime];]
	item[create a file with extension code[xsemantics] in a subdirectory of one of your
	source folders;]
	item[give a name to your code[system], and save;]
	item[you should now have in your project an additional folder code[xsemantics-gen],
	where Xsemantics generates the Java file; make sure to set that folder as a source
	folder (and don't forget to add it also to your code[build.properties] file.]
]

If you see something similar to the following screenshot you should be fine.

img[images/first-xsemantics-file.png][An xsemantics file and generated code][ ][width:90%]

Xsemantics will generate Java classes as explained in ref:CodeGeneration[the next section]

section:CodeGeneration[Generated Code]

Xsemantics will generate two Java classes for each xsemantics system:

ul[
	item[A Java class with the same name of the system, containing
	all the implementations of the system's rules;]
	item[A derived class from codeRef[org.eclipse.xtext.validation.AbstractDeclarativeValidator],
	with the same name of the system with suffix code[Validator] in particular,
	all the generated validators inherits from 
	codeRef[it.xsemantics.runtime.validation.XsemanticsBasedDeclarativeValidator] ; ]
]

The generated classes rely on Google injection, so you must not
instantiate them directly, but only via injection.

This validator should not be used (i.e., injected) directly, since it does
not implement the method code[getEPackages]; so, considering the project
you have just created, the advised way of using it is to copy the code[getEPackages]
from the abstract validator generated by Xtext, e.g., code[AbstractMyDslJavaValidator],
into your code[MyDslJavaValidator], and then make your validator inherit
from the validator generated by Xsemantics, e.g., code[MyDslSystemValidator].
Summarizing, for this example your validator should look like this:

code[Java][
public class MyDslJavaValidator extends MyDslSystemValidator {
	// copied from AbstractMyDslJavaValidator
	@Override
	protected List<EPackage> getEPackages() {
	    List<EPackage> result = new ArrayList<EPackage>();
	    result.add(org.xtext.example.mydsl.myDsl.MyDslPackage.eINSTANCE);
		return result;
	}
}
]

At the moment, this is the way to use the generated validator.

section:Syntax[Xsemantics Syntax]

After giving your system a name, as seen in the previous example, the
first thing to do is to declare the e[judgments] of your system;
a judgment consists of

ul[
	item[a name, which has to be unique in the system;]
	item[a e[judgment symbol] that can be chosen from some predefined symbols;]
	item[the e[parameters] of the judgment; parameters of a judgments are separated by
	a e[relation symbol] that can be chosen from some predefined symbols;]
]

The parameters can be

ul[
item[input parameters, in that case they are declared as Java parameters;]
item[output parameters, in that case you use the keyword code[output] followed
by the Java type of the output parameter.]
]

For instance, these are some examples of judgments, using the
classes from EMF Ecore, and other Java classes

code[Xsemantics][
system my.test.System

import org.eclipse.emf.ecore.*
import java.util.*

judgments {
	type |- EObject obj : output EClassifier
	subtype |- EObject left <: EObject right
	interpret |- EObject exp ~> output EObject
	// nonsense judgment, just a demo
	foobar ||- List<EObject> objects |> output String <~ EClass context
}
]

A judgment can have at least one input parameter, and at most two output
parameters (the latter limitation does not seem to have an impact, since
it is rare to want more than two ouput parameters, but of course, it is
easy to remove this limitation in case).

Once you declared the judgments of your system, you can start declaring the rules.

Each rule consists of

ul[
item[a name, which has to be unique in the system;]
item[a e[rule conclusion];]
item[the e[premises] of the rule;]
]

The rule conclusion consists of

ul[
item[the name of the e[environment] of a rule (any identifier, see
also ref:CodeGeneration[the section about rule environment]);]
item[a e[judgment symbol];]
item[the e[parameters] of the rules, which are separated by
a e[relation symbol] that can be chosen from some predefined symbols;]
]

The things that make a rule belong to a specific judgment are, as you can
imagine, the judgment symbol, the relation symbols (which separate the parameters);
moreover the types of the parameters of a rule must be (Java) subtypes of the
corresponding types of the judgment (or exactly the same Java types).
Two rules belonging to the same judgment must differ for at least one input
parameter's type.

code[Xsemantics][
rule MyFirstTypeRule  // a rule for the judgment 'type'
	G |- EObject o : EClassifier result
from { /* premises */ }

rule MySecondTypeRule  // a rule for the judgment 'type'
	// OK since EClass is a subclass of EObject
	// and EClass extends EClassifier
	G |- EClass o : EClass result
from { /* premises */ }

rule MyFirstWrongTypeRule  // a rule for the judgment 'type'
	// ERROR: Notifier is not a subtype of EObject
	G |- Notifier n : EClass result
from { /* premises */ }

rule MySecondWrongTypeRule  // a rule for the judgment 'type'
	// ERROR: it differs from MyFirstTypeRule only for the
	// output parameter type: EClassImpl
	G |- EObject o : EClass result
from { /* premises */ }

rule MyFirstSubtypeRule  // a rule for the judgment 'subtype'
	G |- EObject o1 <: EObject o2
from { /* premises */ }

rule MySecondSubtypeRule  // a rule for the judgment 'subtype'
	G |- EClass c1 <: EClass c2
from { /* premises */ }

rule MyThirdSubtypeRule  // a rule for the judgment 'subtype'
	G |- EObject o1 <: EClass c2
from { /* premises */ }
]

The premises of a rule which are specified in a code[from] block can be
any Xbase expression, or a rule invocation.  If you think of a rule
declaration as a function declaration, then a rule invocation corresponds
to function invocation, thus you must specify the environment to pass
to the rule, and the arguments, both input and output arguments.

At runtime, the system will select the most appropriate rule according
to the runtime types of the passed argument (similar to
e[polymorphic dispatch] mechanism).

In the premises you can assign values to the output parameters; and
when you invoke another rule, upon return, the output arguments will have
the values assigned in the invoked rule.

If one of the premises fails, then the whole rule will fail, and in turn
all the stack of rule invocation will fail.  If the premise is a boolean
expression, it will fail if the expression evaluates to false
(see also ref:CodeGeneration[the section about boolean expressions] for
a more detailed explanation).  If the premise is a rule invocation,
it will fail if the invoked rule fails.

For instance, consider these implementations:

code[Xsemantics][
rule MyFirstTypeRule  // a rule for the judgment 'type'
	G |- EObject o : EClassifier result
from {
	o.eClass != null
	result = o.eClass
}
]

This rules requires that the feature code[eClass] of the passed code[EObject]
is not null, and the assigns the output parameter code[result].

code[Xsemantics][
rule MyFirstSubtypeRule  // a rule for the judgment 'subtype'
	G |- EObject o1 <: EObject o2
from {
	G |- o1 <: o2.eClass
}
]

This rule simply invokes another rule (in this case of the same judgment), passing
arguments (note that arguments can be any Xbase expression).

code[Xsemantics][
rule MyThirdSubtypeRule  // a rule for the judgment 'subtype'
	G |- EObject o1 <: EClass c2
from {
	var EClass o1Type
	G |- o1 : o1Type
	G |- o1Type <: c2
}
]

This rule declares a local variable code[o1Type] which will be passes (as an output
argument) to a rule invocation (of another judgment: indeed rules can invoke
any other rule in the system, even belonging to a different judgment).
If the rule invocation succeeds, the local variable code[o1Type] will contain
the output result of the invoked rule.  Then, it will invoke another rule. 

code[Xsemantics][
rule MySecondSubtypeRule  // a rule for the judgment 'subtype'
	G |- EClass c1 <: EClass c2
from { /* premises */ }
]

The rule conclusion elements corresponding to output parameters can also
be Xbase expressions; for instance we could have written (compare it with
the above code for the same rule).

code[Xsemantics][
rule MyFirstTypeRule  // a rule for the judgment 'type'
	G |- EObject o : o.eClass
from {
	o.eClass != null
}
]

Moreover, if a rule does not require any premise, we can use a special
form of rules, called indeed e[axiom]s

code[Xsemantics][
// assuming we don't want to do any check
axiom MyFirstTypeRule  // a rule for the judgment 'type'
	G |- EObject o : o.eClass
]

.

section2:ExpressionsInPremises[Expressions in Premises]

Xsemantics consider a Xbase expression as a boolean premise when it is
used as a statement, i.e., it is not the right expression in
an assignment, it is not the condition of a loop.  Moreover, this holds
when the expression is used in a block, NOT in a closure block.
It is crucial to understand when a boolean expression is considered
as a premise since when a premise fails the whole rule fails.

code[Xsemantics][
...
from {
	a != b // boolean premise
	var c = (a != b) // NOT boolean premise
	if (a != b) ... // NOT boolean premise
	list.forEach \[ a != b \] // NOT boolean premise
	// but, be careful:
	list.forEach \[ 
		a != b // NOT boolean premise
		{ a != b } // boolean premise
	\] 
}
]

section2:Environment[Rule Environment]

The concept of rule environment is taken from the type theory
(usually is denoted by the capital greek letter Gamma, that is why
we usually use the letter G for the examples, but you can use any
valid identifier).  It can be used to pass additional argument to rules.
If you want to be sure to pass an empty environment when invoking a rule
you can use the keyword code[empty].

Furthermore, when passing an environment during a rule invocation, you
can specify additional e[environment mapping], using the syntax
code[key <- value], where you can use any Xbase expression;
you can also pass an environment with additional
mappings separated by a comma (or even build an environment from scratch
by specifyin all the mappings, still separated by a comma); for instance
code[G, x <- 'foo', y <- 10] or code[x <- o.eClass, y <- (o.eClass.name == 'foo')],
etc.

Note that when you pass an environment to a rule with additional mappings,
you actually pass a brand new environment, thus you will not modify the
current rule environment; if a mapping already exists in the current rule
environment, in the brand new environment (and only there) the existing mapping
will be overwritten.  Thus, the rule environment passed to a rule acts
in a stack manner.

Inside the premises, you can access the environment using the predefined
function code[env] with the following syntax

code[env(<environment ID>, <key>, <expected Java type>)]

for instance,

code[Xsemantics][
rule MyFirstTypeRule  // a rule for the judgment 'type'
	G |- EObject o : o.eClass
from {
	// search for the mapping for o.eClass.name
	// and request it to be an instance of EClassifier
	var i = env(G, o.eClass.name, EClassifier)
}
]

The code[env] function will fail (and make the rule fail) if no
mapping is found in the passed environment or if the mapped value
is not an instance of the specified Java class.